// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: finance.proto

package finance_service

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EmptyRes struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmptyRes) Reset()         { *m = EmptyRes{} }
func (m *EmptyRes) String() string { return proto.CompactTextString(m) }
func (*EmptyRes) ProtoMessage()    {}
func (*EmptyRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{0}
}
func (m *EmptyRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmptyRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmptyRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyRes.Merge(m, src)
}
func (m *EmptyRes) XXX_Size() int {
	return m.Size()
}
func (m *EmptyRes) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyRes.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyRes proto.InternalMessageInfo

type EmptyReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Category             string   `protobuf:"bytes,2,opt,name=category,proto3" json:"category"`
	PersonalId           string   `protobuf:"bytes,3,opt,name=personal_id,json=personalId,proto3" json:"personal_id"`
	SalaryTypeId         string   `protobuf:"bytes,4,opt,name=salary_type_id,json=salaryTypeId,proto3" json:"salary_type_id"`
	Amount               string   `protobuf:"bytes,5,opt,name=amount,proto3" json:"amount"`
	Comment              string   `protobuf:"bytes,6,opt,name=comment,proto3" json:"comment"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmptyReq) Reset()         { *m = EmptyReq{} }
func (m *EmptyReq) String() string { return proto.CompactTextString(m) }
func (*EmptyReq) ProtoMessage()    {}
func (*EmptyReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{1}
}
func (m *EmptyReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmptyReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmptyReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyReq.Merge(m, src)
}
func (m *EmptyReq) XXX_Size() int {
	return m.Size()
}
func (m *EmptyReq) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyReq.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyReq proto.InternalMessageInfo

func (m *EmptyReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *EmptyReq) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

func (m *EmptyReq) GetPersonalId() string {
	if m != nil {
		return m.PersonalId
	}
	return ""
}

func (m *EmptyReq) GetSalaryTypeId() string {
	if m != nil {
		return m.SalaryTypeId
	}
	return ""
}

func (m *EmptyReq) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *EmptyReq) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

type Empty struct {
	Status               bool     `protobuf:"varint,1,opt,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{2}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

func (m *Empty) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type Request struct {
	Date                 string   `protobuf:"bytes,1,opt,name=date,proto3" json:"date"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{3}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

type Response struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Permission           string   `protobuf:"bytes,3,opt,name=permission,proto3" json:"permission"`
	SalaryMonth          string   `protobuf:"bytes,4,opt,name=salary_month,json=salaryMonth,proto3" json:"salary_month"`
	Given                []*Tesh  `protobuf:"bytes,5,rep,name=given,proto3" json:"given"`
	Debt                 float32  `protobuf:"fixed32,6,opt,name=debt,proto3" json:"debt"`
	Surcharge            float32  `protobuf:"fixed32,7,opt,name=surcharge,proto3" json:"surcharge"`
	PrepaidExpense       float32  `protobuf:"fixed32,8,opt,name=prepaid_expense,json=prepaidExpense,proto3" json:"prepaid_expense"`
	Comment              string   `protobuf:"bytes,9,opt,name=comment,proto3" json:"comment"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{4}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Response) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Response) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

func (m *Response) GetSalaryMonth() string {
	if m != nil {
		return m.SalaryMonth
	}
	return ""
}

func (m *Response) GetGiven() []*Tesh {
	if m != nil {
		return m.Given
	}
	return nil
}

func (m *Response) GetDebt() float32 {
	if m != nil {
		return m.Debt
	}
	return 0
}

func (m *Response) GetSurcharge() float32 {
	if m != nil {
		return m.Surcharge
	}
	return 0
}

func (m *Response) GetPrepaidExpense() float32 {
	if m != nil {
		return m.PrepaidExpense
	}
	return 0
}

func (m *Response) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

type ResponseList struct {
	Salary               []*Response `protobuf:"bytes,1,rep,name=salary,proto3" json:"salary"`
	Count                int64       `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ResponseList) Reset()         { *m = ResponseList{} }
func (m *ResponseList) String() string { return proto.CompactTextString(m) }
func (*ResponseList) ProtoMessage()    {}
func (*ResponseList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{5}
}
func (m *ResponseList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseList.Merge(m, src)
}
func (m *ResponseList) XXX_Size() int {
	return m.Size()
}
func (m *ResponseList) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseList.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseList proto.InternalMessageInfo

func (m *ResponseList) GetSalary() []*Response {
	if m != nil {
		return m.Salary
	}
	return nil
}

func (m *ResponseList) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type Spending struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Amount               string   `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
	Comment              string   `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment"`
	Status               string   `protobuf:"bytes,4,opt,name=status,proto3" json:"status"`
	PysysId              string   `protobuf:"bytes,5,opt,name=pysys_id,json=pysysId,proto3" json:"pysys_id"`
	BranchId             string   `protobuf:"bytes,6,opt,name=branch_id,json=branchId,proto3" json:"branch_id"`
	SpendingTypeId       string   `protobuf:"bytes,7,opt,name=spending_type_id,json=spendingTypeId,proto3" json:"spending_type_id"`
	CreatedAt            string   `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Spending) Reset()         { *m = Spending{} }
func (m *Spending) String() string { return proto.CompactTextString(m) }
func (*Spending) ProtoMessage()    {}
func (*Spending) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{6}
}
func (m *Spending) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Spending) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Spending.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Spending) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Spending.Merge(m, src)
}
func (m *Spending) XXX_Size() int {
	return m.Size()
}
func (m *Spending) XXX_DiscardUnknown() {
	xxx_messageInfo_Spending.DiscardUnknown(m)
}

var xxx_messageInfo_Spending proto.InternalMessageInfo

func (m *Spending) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Spending) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Spending) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Spending) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Spending) GetPysysId() string {
	if m != nil {
		return m.PysysId
	}
	return ""
}

func (m *Spending) GetBranchId() string {
	if m != nil {
		return m.BranchId
	}
	return ""
}

func (m *Spending) GetSpendingTypeId() string {
	if m != nil {
		return m.SpendingTypeId
	}
	return ""
}

func (m *Spending) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *Spending) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type By struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *By) Reset()         { *m = By{} }
func (m *By) String() string { return proto.CompactTextString(m) }
func (*By) ProtoMessage()    {}
func (*By) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{7}
}
func (m *By) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *By) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_By.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *By) XXX_Merge(src proto.Message) {
	xxx_messageInfo_By.Merge(m, src)
}
func (m *By) XXX_Size() int {
	return m.Size()
}
func (m *By) XXX_DiscardUnknown() {
	xxx_messageInfo_By.DiscardUnknown(m)
}

var xxx_messageInfo_By proto.InternalMessageInfo

func (m *By) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *By) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ByP struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	TeacherId            string   `protobuf:"bytes,3,opt,name=teacher_id,json=teacherId,proto3" json:"teacher_id"`
	TeacherName          string   `protobuf:"bytes,4,opt,name=teacher_name,json=teacherName,proto3" json:"teacher_name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ByP) Reset()         { *m = ByP{} }
func (m *ByP) String() string { return proto.CompactTextString(m) }
func (*ByP) ProtoMessage()    {}
func (*ByP) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{8}
}
func (m *ByP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ByP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ByP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ByP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ByP.Merge(m, src)
}
func (m *ByP) XXX_Size() int {
	return m.Size()
}
func (m *ByP) XXX_DiscardUnknown() {
	xxx_messageInfo_ByP.DiscardUnknown(m)
}

var xxx_messageInfo_ByP proto.InternalMessageInfo

func (m *ByP) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ByP) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ByP) GetTeacherId() string {
	if m != nil {
		return m.TeacherId
	}
	return ""
}

func (m *ByP) GetTeacherName() string {
	if m != nil {
		return m.TeacherName
	}
	return ""
}

type SpendingResp struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Amount               string   `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
	Comment              string   `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment"`
	Status               string   `protobuf:"bytes,4,opt,name=status,proto3" json:"status"`
	Pysys                *By      `protobuf:"bytes,5,opt,name=pysys,proto3" json:"pysys"`
	SpendingType         *By      `protobuf:"bytes,6,opt,name=spending_type,json=spendingType,proto3" json:"spending_type"`
	Branch               *By      `protobuf:"bytes,7,opt,name=branch,proto3" json:"branch"`
	CreatedAt            string   `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpendingResp) Reset()         { *m = SpendingResp{} }
func (m *SpendingResp) String() string { return proto.CompactTextString(m) }
func (*SpendingResp) ProtoMessage()    {}
func (*SpendingResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{9}
}
func (m *SpendingResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendingResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendingResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendingResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendingResp.Merge(m, src)
}
func (m *SpendingResp) XXX_Size() int {
	return m.Size()
}
func (m *SpendingResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendingResp.DiscardUnknown(m)
}

var xxx_messageInfo_SpendingResp proto.InternalMessageInfo

func (m *SpendingResp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SpendingResp) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *SpendingResp) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *SpendingResp) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *SpendingResp) GetPysys() *By {
	if m != nil {
		return m.Pysys
	}
	return nil
}

func (m *SpendingResp) GetSpendingType() *By {
	if m != nil {
		return m.SpendingType
	}
	return nil
}

func (m *SpendingResp) GetBranch() *By {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *SpendingResp) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *SpendingResp) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type Payment struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Amount               string   `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
	Type                 string   `protobuf:"bytes,3,opt,name=type,proto3" json:"type"`
	Duration             string   `protobuf:"bytes,4,opt,name=duration,proto3" json:"duration"`
	PysysId              string   `protobuf:"bytes,5,opt,name=pysys_id,json=pysysId,proto3" json:"pysys_id"`
	StudentId            string   `protobuf:"bytes,6,opt,name=student_id,json=studentId,proto3" json:"student_id"`
	DirectionId          string   `protobuf:"bytes,7,opt,name=direction_id,json=directionId,proto3" json:"direction_id"`
	GroupId              string   `protobuf:"bytes,8,opt,name=group_id,json=groupId,proto3" json:"group_id"`
	CreatedAt            string   `protobuf:"bytes,9,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,10,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Payment) Reset()         { *m = Payment{} }
func (m *Payment) String() string { return proto.CompactTextString(m) }
func (*Payment) ProtoMessage()    {}
func (*Payment) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{10}
}
func (m *Payment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payment.Merge(m, src)
}
func (m *Payment) XXX_Size() int {
	return m.Size()
}
func (m *Payment) XXX_DiscardUnknown() {
	xxx_messageInfo_Payment.DiscardUnknown(m)
}

var xxx_messageInfo_Payment proto.InternalMessageInfo

func (m *Payment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Payment) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Payment) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Payment) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

func (m *Payment) GetPysysId() string {
	if m != nil {
		return m.PysysId
	}
	return ""
}

func (m *Payment) GetStudentId() string {
	if m != nil {
		return m.StudentId
	}
	return ""
}

func (m *Payment) GetDirectionId() string {
	if m != nil {
		return m.DirectionId
	}
	return ""
}

func (m *Payment) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *Payment) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *Payment) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type PaymentResp struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Amount               string   `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
	Type                 string   `protobuf:"bytes,3,opt,name=type,proto3" json:"type"`
	Duration             string   `protobuf:"bytes,4,opt,name=duration,proto3" json:"duration"`
	PysysId              *By      `protobuf:"bytes,5,opt,name=pysys_id,json=pysysId,proto3" json:"pysys_id"`
	StudentId            *By      `protobuf:"bytes,6,opt,name=student_id,json=studentId,proto3" json:"student_id"`
	DirectionId          *By      `protobuf:"bytes,7,opt,name=direction_id,json=directionId,proto3" json:"direction_id"`
	GroupId              *ByP     `protobuf:"bytes,8,opt,name=group_id,json=groupId,proto3" json:"group_id"`
	CreatedAt            string   `protobuf:"bytes,9,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,10,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PaymentResp) Reset()         { *m = PaymentResp{} }
func (m *PaymentResp) String() string { return proto.CompactTextString(m) }
func (*PaymentResp) ProtoMessage()    {}
func (*PaymentResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{11}
}
func (m *PaymentResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentResp.Merge(m, src)
}
func (m *PaymentResp) XXX_Size() int {
	return m.Size()
}
func (m *PaymentResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentResp.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentResp proto.InternalMessageInfo

func (m *PaymentResp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PaymentResp) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *PaymentResp) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PaymentResp) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

func (m *PaymentResp) GetPysysId() *By {
	if m != nil {
		return m.PysysId
	}
	return nil
}

func (m *PaymentResp) GetStudentId() *By {
	if m != nil {
		return m.StudentId
	}
	return nil
}

func (m *PaymentResp) GetDirectionId() *By {
	if m != nil {
		return m.DirectionId
	}
	return nil
}

func (m *PaymentResp) GetGroupId() *ByP {
	if m != nil {
		return m.GroupId
	}
	return nil
}

func (m *PaymentResp) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *PaymentResp) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type PaymentListResp struct {
	Payments             []*PaymentResp `protobuf:"bytes,1,rep,name=payments,proto3" json:"payments"`
	Count                int64          `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PaymentListResp) Reset()         { *m = PaymentListResp{} }
func (m *PaymentListResp) String() string { return proto.CompactTextString(m) }
func (*PaymentListResp) ProtoMessage()    {}
func (*PaymentListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{12}
}
func (m *PaymentListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentListResp.Merge(m, src)
}
func (m *PaymentListResp) XXX_Size() int {
	return m.Size()
}
func (m *PaymentListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentListResp.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentListResp proto.InternalMessageInfo

func (m *PaymentListResp) GetPayments() []*PaymentResp {
	if m != nil {
		return m.Payments
	}
	return nil
}

func (m *PaymentListResp) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type SpendingListResp struct {
	Spendings            []*SpendingResp `protobuf:"bytes,1,rep,name=spendings,proto3" json:"spendings"`
	Count                int64           `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SpendingListResp) Reset()         { *m = SpendingListResp{} }
func (m *SpendingListResp) String() string { return proto.CompactTextString(m) }
func (*SpendingListResp) ProtoMessage()    {}
func (*SpendingListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{13}
}
func (m *SpendingListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendingListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendingListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendingListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendingListResp.Merge(m, src)
}
func (m *SpendingListResp) XXX_Size() int {
	return m.Size()
}
func (m *SpendingListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendingListResp.DiscardUnknown(m)
}

var xxx_messageInfo_SpendingListResp proto.InternalMessageInfo

func (m *SpendingListResp) GetSpendings() []*SpendingResp {
	if m != nil {
		return m.Spendings
	}
	return nil
}

func (m *SpendingListResp) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type Searching struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	Amount               float32  `protobuf:"fixed32,2,opt,name=amount,proto3" json:"amount"`
	Paid                 float32  `protobuf:"fixed32,3,opt,name=paid,proto3" json:"paid"`
	Debt                 float32  `protobuf:"fixed32,4,opt,name=debt,proto3" json:"debt"`
	Sum                  float32  `protobuf:"fixed32,5,opt,name=sum,proto3" json:"sum"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Searching) Reset()         { *m = Searching{} }
func (m *Searching) String() string { return proto.CompactTextString(m) }
func (*Searching) ProtoMessage()    {}
func (*Searching) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{14}
}
func (m *Searching) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Searching) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Searching.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Searching) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Searching.Merge(m, src)
}
func (m *Searching) XXX_Size() int {
	return m.Size()
}
func (m *Searching) XXX_DiscardUnknown() {
	xxx_messageInfo_Searching.DiscardUnknown(m)
}

var xxx_messageInfo_Searching proto.InternalMessageInfo

func (m *Searching) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Searching) GetAmount() float32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Searching) GetPaid() float32 {
	if m != nil {
		return m.Paid
	}
	return 0
}

func (m *Searching) GetDebt() float32 {
	if m != nil {
		return m.Debt
	}
	return 0
}

func (m *Searching) GetSum() float32 {
	if m != nil {
		return m.Sum
	}
	return 0
}

type PaymentSearchResp struct {
	Sum                  float32      `protobuf:"fixed32,1,opt,name=sum,proto3" json:"sum"`
	Searching            []*Searching `protobuf:"bytes,2,rep,name=searching,proto3" json:"searching"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PaymentSearchResp) Reset()         { *m = PaymentSearchResp{} }
func (m *PaymentSearchResp) String() string { return proto.CompactTextString(m) }
func (*PaymentSearchResp) ProtoMessage()    {}
func (*PaymentSearchResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{15}
}
func (m *PaymentSearchResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentSearchResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentSearchResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentSearchResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentSearchResp.Merge(m, src)
}
func (m *PaymentSearchResp) XXX_Size() int {
	return m.Size()
}
func (m *PaymentSearchResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentSearchResp.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentSearchResp proto.InternalMessageInfo

func (m *PaymentSearchResp) GetSum() float32 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *PaymentSearchResp) GetSearching() []*Searching {
	if m != nil {
		return m.Searching
	}
	return nil
}

type ProfitResp struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	Count                float32  `protobuf:"fixed32,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProfitResp) Reset()         { *m = ProfitResp{} }
func (m *ProfitResp) String() string { return proto.CompactTextString(m) }
func (*ProfitResp) ProtoMessage()    {}
func (*ProfitResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{16}
}
func (m *ProfitResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfitResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfitResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProfitResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfitResp.Merge(m, src)
}
func (m *ProfitResp) XXX_Size() int {
	return m.Size()
}
func (m *ProfitResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfitResp.DiscardUnknown(m)
}

var xxx_messageInfo_ProfitResp proto.InternalMessageInfo

func (m *ProfitResp) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProfitResp) GetCount() float32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type ProfitRespList struct {
	Count                float32       `protobuf:"fixed32,1,opt,name=count,proto3" json:"count"`
	Direction            []*ProfitResp `protobuf:"bytes,2,rep,name=direction,proto3" json:"direction"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ProfitRespList) Reset()         { *m = ProfitRespList{} }
func (m *ProfitRespList) String() string { return proto.CompactTextString(m) }
func (*ProfitRespList) ProtoMessage()    {}
func (*ProfitRespList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{17}
}
func (m *ProfitRespList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfitRespList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfitRespList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProfitRespList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfitRespList.Merge(m, src)
}
func (m *ProfitRespList) XXX_Size() int {
	return m.Size()
}
func (m *ProfitRespList) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfitRespList.DiscardUnknown(m)
}

var xxx_messageInfo_ProfitRespList proto.InternalMessageInfo

func (m *ProfitRespList) GetCount() float32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ProfitRespList) GetDirection() []*ProfitResp {
	if m != nil {
		return m.Direction
	}
	return nil
}

type ByIdReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ByIdReq) Reset()         { *m = ByIdReq{} }
func (m *ByIdReq) String() string { return proto.CompactTextString(m) }
func (*ByIdReq) ProtoMessage()    {}
func (*ByIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{18}
}
func (m *ByIdReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ByIdReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ByIdReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ByIdReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ByIdReq.Merge(m, src)
}
func (m *ByIdReq) XXX_Size() int {
	return m.Size()
}
func (m *ByIdReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ByIdReq.DiscardUnknown(m)
}

var xxx_messageInfo_ByIdReq proto.InternalMessageInfo

func (m *ByIdReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type ListReq struct {
	Page                 int64    `protobuf:"varint,1,opt,name=page,proto3" json:"page"`
	Limit                int64    `protobuf:"varint,2,opt,name=limit,proto3" json:"limit"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListReq) Reset()         { *m = ListReq{} }
func (m *ListReq) String() string { return proto.CompactTextString(m) }
func (*ListReq) ProtoMessage()    {}
func (*ListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{19}
}
func (m *ListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListReq.Merge(m, src)
}
func (m *ListReq) XXX_Size() int {
	return m.Size()
}
func (m *ListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListReq proto.InternalMessageInfo

func (m *ListReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ListReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type SpendingListReq struct {
	SpendingType         string   `protobuf:"bytes,1,opt,name=spending_type,json=spendingType,proto3" json:"spending_type"`
	Page                 int64    `protobuf:"varint,2,opt,name=page,proto3" json:"page"`
	Limit                int64    `protobuf:"varint,3,opt,name=limit,proto3" json:"limit"`
	Dan                  string   `protobuf:"bytes,4,opt,name=dan,proto3" json:"dan"`
	Gacha                string   `protobuf:"bytes,5,opt,name=gacha,proto3" json:"gacha"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpendingListReq) Reset()         { *m = SpendingListReq{} }
func (m *SpendingListReq) String() string { return proto.CompactTextString(m) }
func (*SpendingListReq) ProtoMessage()    {}
func (*SpendingListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{20}
}
func (m *SpendingListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendingListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendingListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendingListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendingListReq.Merge(m, src)
}
func (m *SpendingListReq) XXX_Size() int {
	return m.Size()
}
func (m *SpendingListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendingListReq.DiscardUnknown(m)
}

var xxx_messageInfo_SpendingListReq proto.InternalMessageInfo

func (m *SpendingListReq) GetSpendingType() string {
	if m != nil {
		return m.SpendingType
	}
	return ""
}

func (m *SpendingListReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *SpendingListReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SpendingListReq) GetDan() string {
	if m != nil {
		return m.Dan
	}
	return ""
}

func (m *SpendingListReq) GetGacha() string {
	if m != nil {
		return m.Gacha
	}
	return ""
}

type SpendingListRequest struct {
	Page                 int64    `protobuf:"varint,1,opt,name=page,proto3" json:"page"`
	Limit                int64    `protobuf:"varint,2,opt,name=limit,proto3" json:"limit"`
	Dan                  string   `protobuf:"bytes,3,opt,name=dan,proto3" json:"dan"`
	Gacha                string   `protobuf:"bytes,4,opt,name=gacha,proto3" json:"gacha"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpendingListRequest) Reset()         { *m = SpendingListRequest{} }
func (m *SpendingListRequest) String() string { return proto.CompactTextString(m) }
func (*SpendingListRequest) ProtoMessage()    {}
func (*SpendingListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{21}
}
func (m *SpendingListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendingListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendingListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendingListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendingListRequest.Merge(m, src)
}
func (m *SpendingListRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpendingListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendingListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpendingListRequest proto.InternalMessageInfo

func (m *SpendingListRequest) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *SpendingListRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SpendingListRequest) GetDan() string {
	if m != nil {
		return m.Dan
	}
	return ""
}

func (m *SpendingListRequest) GetGacha() string {
	if m != nil {
		return m.Gacha
	}
	return ""
}

type PaymentSearchReq struct {
	Dan                  string   `protobuf:"bytes,1,opt,name=dan,proto3" json:"dan"`
	Gacha                string   `protobuf:"bytes,2,opt,name=gacha,proto3" json:"gacha"`
	Id                   string   `protobuf:"bytes,3,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PaymentSearchReq) Reset()         { *m = PaymentSearchReq{} }
func (m *PaymentSearchReq) String() string { return proto.CompactTextString(m) }
func (*PaymentSearchReq) ProtoMessage()    {}
func (*PaymentSearchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{22}
}
func (m *PaymentSearchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentSearchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentSearchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentSearchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentSearchReq.Merge(m, src)
}
func (m *PaymentSearchReq) XXX_Size() int {
	return m.Size()
}
func (m *PaymentSearchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentSearchReq.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentSearchReq proto.InternalMessageInfo

func (m *PaymentSearchReq) GetDan() string {
	if m != nil {
		return m.Dan
	}
	return ""
}

func (m *PaymentSearchReq) GetGacha() string {
	if m != nil {
		return m.Gacha
	}
	return ""
}

func (m *PaymentSearchReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type SearchReq struct {
	Dan                  string   `protobuf:"bytes,1,opt,name=dan,proto3" json:"dan"`
	Gacha                string   `protobuf:"bytes,2,opt,name=gacha,proto3" json:"gacha"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchReq) Reset()         { *m = SearchReq{} }
func (m *SearchReq) String() string { return proto.CompactTextString(m) }
func (*SearchReq) ProtoMessage()    {}
func (*SearchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{23}
}
func (m *SearchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchReq.Merge(m, src)
}
func (m *SearchReq) XXX_Size() int {
	return m.Size()
}
func (m *SearchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchReq.DiscardUnknown(m)
}

var xxx_messageInfo_SearchReq proto.InternalMessageInfo

func (m *SearchReq) GetDan() string {
	if m != nil {
		return m.Dan
	}
	return ""
}

func (m *SearchReq) GetGacha() string {
	if m != nil {
		return m.Gacha
	}
	return ""
}

type Search struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	TeacherName          string   `protobuf:"bytes,3,opt,name=teacher_name,json=teacherName,proto3" json:"teacher_name"`
	CountStudent         int64    `protobuf:"varint,4,opt,name=countStudent,proto3" json:"countStudent"`
	Amount               string   `protobuf:"bytes,5,opt,name=amount,proto3" json:"amount"`
	Paid                 string   `protobuf:"bytes,6,opt,name=paid,proto3" json:"paid"`
	Debt                 string   `protobuf:"bytes,7,opt,name=debt,proto3" json:"debt"`
	TotalAmount          string   `protobuf:"bytes,8,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Search) Reset()         { *m = Search{} }
func (m *Search) String() string { return proto.CompactTextString(m) }
func (*Search) ProtoMessage()    {}
func (*Search) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{24}
}
func (m *Search) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Search) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Search.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Search) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Search.Merge(m, src)
}
func (m *Search) XXX_Size() int {
	return m.Size()
}
func (m *Search) XXX_DiscardUnknown() {
	xxx_messageInfo_Search.DiscardUnknown(m)
}

var xxx_messageInfo_Search proto.InternalMessageInfo

func (m *Search) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Search) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Search) GetTeacherName() string {
	if m != nil {
		return m.TeacherName
	}
	return ""
}

func (m *Search) GetCountStudent() int64 {
	if m != nil {
		return m.CountStudent
	}
	return 0
}

func (m *Search) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Search) GetPaid() string {
	if m != nil {
		return m.Paid
	}
	return ""
}

func (m *Search) GetDebt() string {
	if m != nil {
		return m.Debt
	}
	return ""
}

func (m *Search) GetTotalAmount() string {
	if m != nil {
		return m.TotalAmount
	}
	return ""
}

type SearchListResp struct {
	Search               []*Search `protobuf:"bytes,1,rep,name=search,proto3" json:"search"`
	Sum                  string    `protobuf:"bytes,2,opt,name=sum,proto3" json:"sum"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SearchListResp) Reset()         { *m = SearchListResp{} }
func (m *SearchListResp) String() string { return proto.CompactTextString(m) }
func (*SearchListResp) ProtoMessage()    {}
func (*SearchListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{25}
}
func (m *SearchListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchListResp.Merge(m, src)
}
func (m *SearchListResp) XXX_Size() int {
	return m.Size()
}
func (m *SearchListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchListResp.DiscardUnknown(m)
}

var xxx_messageInfo_SearchListResp proto.InternalMessageInfo

func (m *SearchListResp) GetSearch() []*Search {
	if m != nil {
		return m.Search
	}
	return nil
}

func (m *SearchListResp) GetSum() string {
	if m != nil {
		return m.Sum
	}
	return ""
}

type Tesh struct {
	Given                string   `protobuf:"bytes,1,opt,name=given,proto3" json:"given"`
	Date                 string   `protobuf:"bytes,2,opt,name=date,proto3" json:"date"`
	Comment              string   `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment"`
	Status               string   `protobuf:"bytes,4,opt,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tesh) Reset()         { *m = Tesh{} }
func (m *Tesh) String() string { return proto.CompactTextString(m) }
func (*Tesh) ProtoMessage()    {}
func (*Tesh) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{26}
}
func (m *Tesh) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tesh) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tesh.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tesh) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tesh.Merge(m, src)
}
func (m *Tesh) XXX_Size() int {
	return m.Size()
}
func (m *Tesh) XXX_DiscardUnknown() {
	xxx_messageInfo_Tesh.DiscardUnknown(m)
}

var xxx_messageInfo_Tesh proto.InternalMessageInfo

func (m *Tesh) GetGiven() string {
	if m != nil {
		return m.Given
	}
	return ""
}

func (m *Tesh) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *Tesh) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Tesh) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type Count struct {
	Count                int64    `protobuf:"varint,1,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Count) Reset()         { *m = Count{} }
func (m *Count) String() string { return proto.CompactTextString(m) }
func (*Count) ProtoMessage()    {}
func (*Count) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{27}
}
func (m *Count) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Count) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Count.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Count) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Count.Merge(m, src)
}
func (m *Count) XXX_Size() int {
	return m.Size()
}
func (m *Count) XXX_DiscardUnknown() {
	xxx_messageInfo_Count.DiscardUnknown(m)
}

var xxx_messageInfo_Count proto.InternalMessageInfo

func (m *Count) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func init() {
	proto.RegisterType((*EmptyRes)(nil), "finance_service.EmptyRes")
	proto.RegisterType((*EmptyReq)(nil), "finance_service.EmptyReq")
	proto.RegisterType((*Empty)(nil), "finance_service.Empty")
	proto.RegisterType((*Request)(nil), "finance_service.Request")
	proto.RegisterType((*Response)(nil), "finance_service.Response")
	proto.RegisterType((*ResponseList)(nil), "finance_service.ResponseList")
	proto.RegisterType((*Spending)(nil), "finance_service.Spending")
	proto.RegisterType((*By)(nil), "finance_service.By")
	proto.RegisterType((*ByP)(nil), "finance_service.ByP")
	proto.RegisterType((*SpendingResp)(nil), "finance_service.SpendingResp")
	proto.RegisterType((*Payment)(nil), "finance_service.Payment")
	proto.RegisterType((*PaymentResp)(nil), "finance_service.PaymentResp")
	proto.RegisterType((*PaymentListResp)(nil), "finance_service.PaymentListResp")
	proto.RegisterType((*SpendingListResp)(nil), "finance_service.SpendingListResp")
	proto.RegisterType((*Searching)(nil), "finance_service.Searching")
	proto.RegisterType((*PaymentSearchResp)(nil), "finance_service.PaymentSearchResp")
	proto.RegisterType((*ProfitResp)(nil), "finance_service.ProfitResp")
	proto.RegisterType((*ProfitRespList)(nil), "finance_service.ProfitRespList")
	proto.RegisterType((*ByIdReq)(nil), "finance_service.ByIdReq")
	proto.RegisterType((*ListReq)(nil), "finance_service.ListReq")
	proto.RegisterType((*SpendingListReq)(nil), "finance_service.SpendingListReq")
	proto.RegisterType((*SpendingListRequest)(nil), "finance_service.SpendingListRequest")
	proto.RegisterType((*PaymentSearchReq)(nil), "finance_service.PaymentSearchReq")
	proto.RegisterType((*SearchReq)(nil), "finance_service.SearchReq")
	proto.RegisterType((*Search)(nil), "finance_service.Search")
	proto.RegisterType((*SearchListResp)(nil), "finance_service.SearchListResp")
	proto.RegisterType((*Tesh)(nil), "finance_service.Tesh")
	proto.RegisterType((*Count)(nil), "finance_service.Count")
}

func init() { proto.RegisterFile("finance.proto", fileDescriptor_c04e2e1c1ba79a81) }

var fileDescriptor_c04e2e1c1ba79a81 = []byte{
	// 1358 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x8e, 0xdc, 0xc4,
	0x13, 0xff, 0xdb, 0x9e, 0x2f, 0xd7, 0x6c, 0x66, 0xf7, 0xdf, 0x09, 0xc1, 0x99, 0x64, 0x36, 0x1b,
	0x83, 0xc4, 0xa2, 0x48, 0x1b, 0xb1, 0x91, 0xa2, 0x20, 0x2e, 0x64, 0xf3, 0x01, 0xc3, 0x97, 0x56,
	0x9e, 0x20, 0x8e, 0xa3, 0x5e, 0xbb, 0x33, 0x63, 0xb1, 0x63, 0x7b, 0x6c, 0x4f, 0x84, 0xef, 0x1c,
	0x38, 0x70, 0xe3, 0x00, 0x6f, 0xc1, 0x95, 0x47, 0xe0, 0xc8, 0x89, 0x33, 0x5a, 0x5e, 0x80, 0x47,
	0x40, 0x5d, 0xdd, 0x6d, 0x7b, 0xc6, 0xf6, 0xb2, 0x9b, 0xc0, 0xad, 0xbb, 0xaa, 0xba, 0xba, 0xea,
	0x57, 0xbf, 0x2e, 0x77, 0x1b, 0xae, 0xbc, 0xf0, 0x03, 0x1a, 0xb8, 0xec, 0x20, 0x8a, 0xc3, 0x34,
	0x24, 0xdb, 0x72, 0x3a, 0x4d, 0x58, 0xfc, 0xd2, 0x77, 0x99, 0x0d, 0xd0, 0x7b, 0xba, 0x88, 0xd2,
	0xcc, 0x61, 0x89, 0xfd, 0xb3, 0x96, 0x4f, 0x96, 0x64, 0x00, 0xba, 0xef, 0x59, 0xda, 0x9e, 0xb6,
	0x6f, 0x3a, 0xba, 0xef, 0x91, 0x21, 0xf4, 0x5c, 0x9a, 0xb2, 0x59, 0x18, 0x67, 0x96, 0x8e, 0xd2,
	0x7c, 0x4e, 0x6e, 0x43, 0x3f, 0x62, 0x71, 0x12, 0x06, 0xf4, 0x74, 0xea, 0x7b, 0x96, 0x81, 0x6a,
	0x50, 0xa2, 0xb1, 0x47, 0xde, 0x86, 0x41, 0x42, 0x4f, 0x69, 0x9c, 0x4d, 0xd3, 0x2c, 0x62, 0xdc,
	0xa6, 0x85, 0x36, 0x5b, 0x42, 0xfa, 0x3c, 0x8b, 0xd8, 0xd8, 0x23, 0xd7, 0xa1, 0x43, 0x17, 0xe1,
	0x2a, 0x48, 0xad, 0x36, 0x6a, 0xe5, 0x8c, 0x58, 0xd0, 0x75, 0xc3, 0xc5, 0x82, 0x05, 0xa9, 0xd5,
	0x41, 0x85, 0x9a, 0xda, 0xb7, 0xa1, 0x8d, 0x01, 0xf3, 0xa5, 0x49, 0x4a, 0xd3, 0x55, 0x82, 0x11,
	0xf7, 0x1c, 0x39, 0xb3, 0x47, 0xd0, 0x75, 0xd8, 0x72, 0xc5, 0x92, 0x94, 0x10, 0x68, 0x79, 0x34,
	0x65, 0x32, 0x25, 0x1c, 0xdb, 0x3f, 0xe8, 0xd0, 0x73, 0x58, 0x12, 0x85, 0x41, 0xc2, 0x2a, 0x19,
	0x13, 0x68, 0x05, 0x74, 0xc1, 0x64, 0xb6, 0x38, 0x26, 0xbb, 0xc0, 0xd3, 0x5a, 0xf8, 0x49, 0xe2,
	0x87, 0x41, 0x29, 0x51, 0x29, 0x21, 0x77, 0x40, 0xa6, 0x34, 0x5d, 0x84, 0x41, 0x3a, 0x97, 0x69,
	0xf6, 0x85, 0xec, 0x73, 0x2e, 0x22, 0x77, 0xa1, 0x3d, 0xf3, 0x5f, 0xb2, 0xc0, 0x6a, 0xef, 0x19,
	0xfb, 0xfd, 0xc3, 0x37, 0x0e, 0x36, 0x4a, 0x72, 0xf0, 0x9c, 0x25, 0x73, 0x47, 0xd8, 0x60, 0xd0,
	0xec, 0x44, 0xe4, 0xad, 0x3b, 0x38, 0x26, 0xb7, 0xc0, 0x4c, 0x56, 0xb1, 0x3b, 0xa7, 0xf1, 0x8c,
	0x59, 0x5d, 0x54, 0x14, 0x02, 0xf2, 0x0e, 0x6c, 0x47, 0x31, 0x8b, 0xa8, 0xef, 0x4d, 0xd9, 0x37,
	0x11, 0x0b, 0x12, 0x66, 0xf5, 0xd0, 0x66, 0x20, 0xc5, 0x4f, 0x85, 0xb4, 0x8c, 0xaa, 0xb9, 0x8e,
	0xea, 0x57, 0xb0, 0xa5, 0x40, 0xf9, 0xcc, 0x4f, 0x52, 0xf2, 0x1e, 0x74, 0x44, 0x02, 0x96, 0x86,
	0x21, 0xdf, 0xa8, 0x84, 0xac, 0xcc, 0x1d, 0x69, 0x48, 0xae, 0x41, 0xdb, 0xc5, 0x4a, 0x72, 0xf0,
	0x0c, 0x47, 0x4c, 0xec, 0x6f, 0x75, 0xe8, 0x4d, 0x22, 0x16, 0x78, 0x7e, 0x30, 0xab, 0xc0, 0x5d,
	0x54, 0x5f, 0x6f, 0xaa, 0xbe, 0xb1, 0x16, 0x67, 0xa9, 0xe8, 0x02, 0x66, 0x39, 0x23, 0x37, 0xa0,
	0x17, 0x65, 0x49, 0x96, 0x70, 0x9e, 0x09, 0x26, 0x75, 0x71, 0x3e, 0xf6, 0xc8, 0x4d, 0x30, 0x4f,
	0x62, 0x1a, 0xb8, 0x73, 0xae, 0x13, 0x64, 0xea, 0x09, 0xc1, 0xd8, 0x23, 0xfb, 0xb0, 0x93, 0xc8,
	0xe8, 0x72, 0x9e, 0x76, 0xd1, 0x66, 0xa0, 0xe4, 0x92, 0xa9, 0x23, 0x00, 0x37, 0x66, 0x34, 0x65,
	0xde, 0x94, 0xa6, 0x88, 0xaf, 0xe9, 0x98, 0x52, 0xf2, 0x28, 0xe5, 0xea, 0x55, 0xe4, 0x29, 0xb5,
	0x40, 0xd7, 0x94, 0x92, 0x47, 0xa9, 0xbd, 0x0f, 0xfa, 0x51, 0x76, 0x11, 0xba, 0xd9, 0x5f, 0x83,
	0x71, 0x94, 0x1d, 0x5f, 0x88, 0x99, 0x23, 0x80, 0x94, 0x51, 0x77, 0xce, 0xe2, 0xe2, 0x08, 0x9a,
	0x52, 0x32, 0xf6, 0x38, 0x31, 0x95, 0x1a, 0x97, 0x4a, 0x62, 0x4a, 0xd9, 0x17, 0x7c, 0xb3, 0x5f,
	0x74, 0xd8, 0x52, 0xd5, 0xe1, 0x05, 0xfd, 0x0f, 0x2b, 0xf4, 0x2e, 0xb4, 0xb1, 0x22, 0x58, 0x9e,
	0xfe, 0xe1, 0xd5, 0x0a, 0xa1, 0x8e, 0x32, 0x47, 0x58, 0x90, 0x87, 0x70, 0x65, 0xad, 0x28, 0x58,
	0xb5, 0x86, 0x25, 0x5b, 0xe5, 0x32, 0x91, 0xbb, 0xd0, 0x11, 0xa5, 0xc5, 0x22, 0x36, 0x2c, 0x91,
	0x26, 0xaf, 0x59, 0xd1, 0x1f, 0x75, 0xe8, 0x1e, 0xd3, 0x0c, 0x73, 0xbe, 0x28, 0x6a, 0x04, 0x5a,
	0x98, 0x8f, 0x80, 0x0c, 0xc7, 0xbc, 0xc9, 0x7a, 0xab, 0x98, 0xa6, 0xbc, 0xb9, 0x08, 0xc4, 0xf2,
	0xf9, 0x79, 0xac, 0x1e, 0x01, 0x24, 0xe9, 0xca, 0x63, 0x41, 0x5a, 0xd0, 0xda, 0x94, 0x12, 0x51,
	0x7b, 0xcf, 0x8f, 0x99, 0xcb, 0xdd, 0x14, 0x9c, 0xee, 0xe7, 0xb2, 0xb1, 0xc7, 0x9d, 0xcf, 0xe2,
	0x70, 0x15, 0x71, 0xb5, 0x48, 0xbe, 0x8b, 0xf3, 0x0a, 0xd7, 0xcd, 0xf3, 0x91, 0x81, 0x4d, 0x64,
	0xfe, 0xd2, 0xa1, 0x2f, 0x91, 0xb9, 0x14, 0xa7, 0x2e, 0x8b, 0xce, 0xc1, 0x06, 0x3a, 0x0d, 0xe5,
	0xce, 0x21, 0x3b, 0xac, 0x40, 0xd6, 0xb0, 0xa2, 0x84, 0xe3, 0x83, 0x1a, 0x1c, 0x1b, 0x56, 0xad,
	0x81, 0x7b, 0x6f, 0x03, 0xdc, 0xfe, 0xe1, 0xb5, 0x9a, 0x35, 0xc7, 0xff, 0x16, 0xe4, 0x14, 0xb6,
	0x25, 0xe2, 0xbc, 0x7b, 0x23, 0xea, 0x0f, 0xa1, 0x17, 0x09, 0x51, 0x22, 0x7b, 0xf8, 0xad, 0x4a,
	0x04, 0xa5, 0x2a, 0x39, 0xb9, 0x75, 0x43, 0x23, 0x67, 0xb0, 0xa3, 0x3a, 0x45, 0xbe, 0xc7, 0x07,
	0x60, 0xaa, 0xe3, 0xa7, 0x36, 0x19, 0x55, 0x36, 0x29, 0xf7, 0x17, 0xa7, 0xb0, 0x6f, 0xd8, 0x66,
	0x09, 0xe6, 0x84, 0xd1, 0xd8, 0x9d, 0xf3, 0xef, 0x85, 0x6a, 0x7a, 0x5a, 0xa9, 0xe9, 0xad, 0xb3,
	0x47, 0x2f, 0xb3, 0x87, 0x7f, 0xea, 0x90, 0x3d, 0xba, 0x83, 0xe3, 0xfc, 0x53, 0xda, 0x2a, 0x7d,
	0x4a, 0x77, 0xc0, 0x48, 0x56, 0x0b, 0x24, 0x8c, 0xee, 0xf0, 0xa1, 0x3d, 0x85, 0xff, 0x4b, 0x20,
	0xc4, 0xce, 0x98, 0x9a, 0x34, 0xd3, 0x72, 0x33, 0xf2, 0x10, 0xcc, 0x44, 0x45, 0x66, 0xe9, 0x98,
	0xec, 0xb0, 0x9a, 0xac, 0xb2, 0x70, 0x0a, 0x63, 0xfb, 0x01, 0xc0, 0x71, 0x1c, 0xbe, 0xf0, 0x05,
	0x68, 0x75, 0x49, 0xad, 0x61, 0xa1, 0x2b, 0x2c, 0x28, 0x0c, 0x8a, 0x75, 0xf8, 0x59, 0xce, 0xed,
	0xb4, 0x92, 0x1d, 0x79, 0x1f, 0xcc, 0x9c, 0x7b, 0x32, 0xb2, 0x9b, 0xd5, 0x5a, 0xe7, 0x9e, 0x9c,
	0xc2, 0xda, 0xbe, 0x01, 0xdd, 0xa3, 0x6c, 0xec, 0xd5, 0xdc, 0xfe, 0xec, 0xfb, 0xd0, 0x15, 0x85,
	0x5e, 0x0a, 0x6c, 0x67, 0x22, 0x64, 0xc3, 0xc1, 0x31, 0x0f, 0xe5, 0xd4, 0x5f, 0xf8, 0x79, 0xf9,
	0x70, 0x62, 0x7f, 0xa7, 0xc1, 0xf6, 0x3a, 0x4d, 0x96, 0xe4, 0xad, 0xcd, 0x76, 0xae, 0xc9, 0x8b,
	0x60, 0xb9, 0x73, 0xab, 0x2d, 0xf4, 0xba, 0x2d, 0x8c, 0xd2, 0x16, 0xbc, 0x32, 0x1e, 0x55, 0xdd,
	0x80, 0x0f, 0xb9, 0xdd, 0x8c, 0xba, 0x73, 0x2a, 0x7b, 0xa4, 0x98, 0xd8, 0x33, 0xb8, 0xba, 0x11,
	0x89, 0xba, 0x13, 0x5e, 0x2c, 0x17, 0xb5, 0x91, 0x51, 0xb3, 0x51, 0xab, 0xbc, 0xd1, 0x27, 0xb0,
	0xb3, 0xc1, 0x9f, 0xa5, 0x5a, 0xab, 0xd5, 0xac, 0xd5, 0x4b, 0x6b, 0x25, 0xe8, 0x46, 0x09, 0x74,
	0xf3, 0xd2, 0x4e, 0xec, 0xdf, 0x35, 0xe8, 0x88, 0x55, 0x17, 0xba, 0x36, 0x6c, 0xde, 0x0b, 0x8c,
	0xca, 0xbd, 0x80, 0xd8, 0xb0, 0x85, 0xd4, 0x9a, 0x88, 0x46, 0x88, 0xf9, 0x1a, 0xce, 0x9a, 0xac,
	0xf1, 0xea, 0xae, 0x0e, 0xa2, 0xf8, 0x26, 0xad, 0x1f, 0xc4, 0xae, 0xbc, 0x88, 0xf3, 0x83, 0xc8,
	0xc3, 0x08, 0x53, 0x7a, 0x3a, 0x95, 0x5e, 0x7a, 0x32, 0x0c, 0x2e, 0x7b, 0x84, 0x22, 0x7b, 0x02,
	0x03, 0x91, 0x57, 0xde, 0x71, 0xee, 0x41, 0x47, 0x9c, 0x2b, 0xd9, 0x6e, 0xde, 0x6c, 0x38, 0x81,
	0x8e, 0x34, 0x53, 0xe7, 0x58, 0xe4, 0x8f, 0xc7, 0xfd, 0x04, 0x5a, 0xfc, 0xba, 0x8d, 0x58, 0xe2,
	0xa5, 0x5c, 0x93, 0x58, 0xe6, 0xb7, 0x6f, 0xfe, 0x64, 0xd0, 0x8b, 0x27, 0xc3, 0xe5, 0x2f, 0x3b,
	0xf6, 0x08, 0xda, 0x8f, 0x11, 0x8c, 0xb5, 0x03, 0xab, 0x9a, 0xdc, 0xe1, 0xf7, 0x3d, 0x18, 0x3c,
	0x13, 0x71, 0x4f, 0x44, 0xd8, 0xe4, 0x31, 0x5c, 0x91, 0x24, 0x7a, 0x8c, 0x4d, 0x9f, 0x58, 0x4d,
	0xdd, 0x7a, 0xd8, 0xa8, 0x21, 0x1f, 0x02, 0xc8, 0xe1, 0x47, 0x2c, 0xad, 0xf1, 0x20, 0x8f, 0xfa,
	0x39, 0x1e, 0xc6, 0xf9, 0xa7, 0x1b, 0xfb, 0x4d, 0xd5, 0x50, 0x1e, 0xa5, 0xe1, 0x5e, 0x93, 0x8b,
	0xbc, 0x54, 0xc7, 0x1b, 0x6d, 0x15, 0x1d, 0x36, 0x75, 0x4c, 0xee, 0xf2, 0x76, 0x83, 0x2e, 0xf7,
	0x58, 0x60, 0xf4, 0x65, 0xe4, 0xbd, 0x2a, 0x46, 0x4f, 0x72, 0x27, 0x4f, 0xd8, 0x29, 0xab, 0x75,
	0xa2, 0x60, 0xaa, 0x3e, 0x7a, 0xd4, 0xbb, 0x99, 0x3c, 0x81, 0x8e, 0x68, 0xa8, 0xa4, 0xd9, 0xa8,
	0x26, 0xa1, 0x8d, 0x76, 0xfe, 0x31, 0x5c, 0x9d, 0xe0, 0xe3, 0x49, 0x92, 0x41, 0x96, 0xbe, 0xd1,
	0xe5, 0x72, 0x78, 0xbd, 0x5e, 0x45, 0x3e, 0x85, 0x9d, 0x35, 0x4f, 0xf5, 0xf5, 0x97, 0x3d, 0x70,
	0x38, 0x6a, 0x7c, 0xcd, 0x61, 0x58, 0xcf, 0x60, 0xa0, 0x3a, 0x67, 0x63, 0x44, 0xca, 0x60, 0xd8,
	0xac, 0x22, 0x47, 0xd0, 0x57, 0xe3, 0xf3, 0xf9, 0x78, 0x8e, 0x8f, 0x49, 0xf1, 0x40, 0xc1, 0xd8,
	0xf6, 0x1a, 0x4d, 0x15, 0x33, 0xef, 0xfc, 0x83, 0x45, 0x12, 0x95, 0x13, 0x94, 0x4c, 0x7a, 0xb5,
	0x04, 0x9f, 0x16, 0x7e, 0x5e, 0x83, 0x4c, 0x47, 0x3b, 0xbf, 0x9e, 0xed, 0x6a, 0xbf, 0x9d, 0xed,
	0x6a, 0x7f, 0x9c, 0xed, 0x6a, 0x3f, 0xfd, 0xb9, 0xfb, 0xbf, 0x93, 0x0e, 0xfe, 0xba, 0xb9, 0xff,
	0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xaf, 0x78, 0xca, 0x66, 0xcb, 0x11, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FinanceServiceClient is the client API for FinanceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FinanceServiceClient interface {
	PaymentCreate(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Payment, error)
	PaymentGet(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*Payment, error)
	PaymentList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*PaymentListResp, error)
	PaymentSearchList(ctx context.Context, in *SearchReq, opts ...grpc.CallOption) (*SearchListResp, error)
	PaymentUpdate(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Payment, error)
	PaymentDelete(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*EmptyRes, error)
	Profit(ctx context.Context, in *EmptyRes, opts ...grpc.CallOption) (*ProfitRespList, error)
	SalaryFinanceCreate(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (*Empty, error)
	SalaryFinanceGet(ctx context.Context, in *Request, opts ...grpc.CallOption) (*ResponseList, error)
	SpendingCreate(ctx context.Context, in *Spending, opts ...grpc.CallOption) (*Spending, error)
	SpendingGet(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*Spending, error)
	SpendingList(ctx context.Context, in *SpendingListReq, opts ...grpc.CallOption) (*SpendingListResp, error)
	SpendingUpdate(ctx context.Context, in *Spending, opts ...grpc.CallOption) (*Spending, error)
	SpendingDelete(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*EmptyRes, error)
}

type financeServiceClient struct {
	cc *grpc.ClientConn
}

func NewFinanceServiceClient(cc *grpc.ClientConn) FinanceServiceClient {
	return &financeServiceClient{cc}
}

func (c *financeServiceClient) PaymentCreate(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Payment, error) {
	out := new(Payment)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) PaymentGet(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*Payment, error) {
	out := new(Payment)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) PaymentList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*PaymentListResp, error) {
	out := new(PaymentListResp)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) PaymentSearchList(ctx context.Context, in *SearchReq, opts ...grpc.CallOption) (*SearchListResp, error) {
	out := new(SearchListResp)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentSearchList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) PaymentUpdate(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Payment, error) {
	out := new(Payment)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) PaymentDelete(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*EmptyRes, error) {
	out := new(EmptyRes)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) Profit(ctx context.Context, in *EmptyRes, opts ...grpc.CallOption) (*ProfitRespList, error) {
	out := new(ProfitRespList)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/Profit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SalaryFinanceCreate(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SalaryFinanceCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SalaryFinanceGet(ctx context.Context, in *Request, opts ...grpc.CallOption) (*ResponseList, error) {
	out := new(ResponseList)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SalaryFinanceGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SpendingCreate(ctx context.Context, in *Spending, opts ...grpc.CallOption) (*Spending, error) {
	out := new(Spending)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SpendingCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SpendingGet(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*Spending, error) {
	out := new(Spending)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SpendingGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SpendingList(ctx context.Context, in *SpendingListReq, opts ...grpc.CallOption) (*SpendingListResp, error) {
	out := new(SpendingListResp)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SpendingList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SpendingUpdate(ctx context.Context, in *Spending, opts ...grpc.CallOption) (*Spending, error) {
	out := new(Spending)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SpendingUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SpendingDelete(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*EmptyRes, error) {
	out := new(EmptyRes)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SpendingDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FinanceServiceServer is the server API for FinanceService service.
type FinanceServiceServer interface {
	PaymentCreate(context.Context, *Payment) (*Payment, error)
	PaymentGet(context.Context, *ByIdReq) (*Payment, error)
	PaymentList(context.Context, *ListReq) (*PaymentListResp, error)
	PaymentSearchList(context.Context, *SearchReq) (*SearchListResp, error)
	PaymentUpdate(context.Context, *Payment) (*Payment, error)
	PaymentDelete(context.Context, *ByIdReq) (*EmptyRes, error)
	Profit(context.Context, *EmptyRes) (*ProfitRespList, error)
	SalaryFinanceCreate(context.Context, *EmptyReq) (*Empty, error)
	SalaryFinanceGet(context.Context, *Request) (*ResponseList, error)
	SpendingCreate(context.Context, *Spending) (*Spending, error)
	SpendingGet(context.Context, *ByIdReq) (*Spending, error)
	SpendingList(context.Context, *SpendingListReq) (*SpendingListResp, error)
	SpendingUpdate(context.Context, *Spending) (*Spending, error)
	SpendingDelete(context.Context, *ByIdReq) (*EmptyRes, error)
}

// UnimplementedFinanceServiceServer can be embedded to have forward compatible implementations.
type UnimplementedFinanceServiceServer struct {
}

func (*UnimplementedFinanceServiceServer) PaymentCreate(ctx context.Context, req *Payment) (*Payment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentCreate not implemented")
}
func (*UnimplementedFinanceServiceServer) PaymentGet(ctx context.Context, req *ByIdReq) (*Payment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentGet not implemented")
}
func (*UnimplementedFinanceServiceServer) PaymentList(ctx context.Context, req *ListReq) (*PaymentListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentList not implemented")
}
func (*UnimplementedFinanceServiceServer) PaymentSearchList(ctx context.Context, req *SearchReq) (*SearchListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentSearchList not implemented")
}
func (*UnimplementedFinanceServiceServer) PaymentUpdate(ctx context.Context, req *Payment) (*Payment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentUpdate not implemented")
}
func (*UnimplementedFinanceServiceServer) PaymentDelete(ctx context.Context, req *ByIdReq) (*EmptyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentDelete not implemented")
}
func (*UnimplementedFinanceServiceServer) Profit(ctx context.Context, req *EmptyRes) (*ProfitRespList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Profit not implemented")
}
func (*UnimplementedFinanceServiceServer) SalaryFinanceCreate(ctx context.Context, req *EmptyReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SalaryFinanceCreate not implemented")
}
func (*UnimplementedFinanceServiceServer) SalaryFinanceGet(ctx context.Context, req *Request) (*ResponseList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SalaryFinanceGet not implemented")
}
func (*UnimplementedFinanceServiceServer) SpendingCreate(ctx context.Context, req *Spending) (*Spending, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpendingCreate not implemented")
}
func (*UnimplementedFinanceServiceServer) SpendingGet(ctx context.Context, req *ByIdReq) (*Spending, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpendingGet not implemented")
}
func (*UnimplementedFinanceServiceServer) SpendingList(ctx context.Context, req *SpendingListReq) (*SpendingListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpendingList not implemented")
}
func (*UnimplementedFinanceServiceServer) SpendingUpdate(ctx context.Context, req *Spending) (*Spending, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpendingUpdate not implemented")
}
func (*UnimplementedFinanceServiceServer) SpendingDelete(ctx context.Context, req *ByIdReq) (*EmptyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpendingDelete not implemented")
}

func RegisterFinanceServiceServer(s *grpc.Server, srv FinanceServiceServer) {
	s.RegisterService(&_FinanceService_serviceDesc, srv)
}

func _FinanceService_PaymentCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Payment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentCreate(ctx, req.(*Payment))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_PaymentGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentGet(ctx, req.(*ByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_PaymentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentList(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_PaymentSearchList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentSearchList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentSearchList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentSearchList(ctx, req.(*SearchReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_PaymentUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Payment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentUpdate(ctx, req.(*Payment))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_PaymentDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentDelete(ctx, req.(*ByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_Profit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).Profit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/Profit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).Profit(ctx, req.(*EmptyRes))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SalaryFinanceCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SalaryFinanceCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SalaryFinanceCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SalaryFinanceCreate(ctx, req.(*EmptyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SalaryFinanceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SalaryFinanceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SalaryFinanceGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SalaryFinanceGet(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SpendingCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Spending)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SpendingCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SpendingCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SpendingCreate(ctx, req.(*Spending))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SpendingGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SpendingGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SpendingGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SpendingGet(ctx, req.(*ByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SpendingList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpendingListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SpendingList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SpendingList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SpendingList(ctx, req.(*SpendingListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SpendingUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Spending)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SpendingUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SpendingUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SpendingUpdate(ctx, req.(*Spending))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SpendingDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SpendingDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SpendingDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SpendingDelete(ctx, req.(*ByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _FinanceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "finance_service.FinanceService",
	HandlerType: (*FinanceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PaymentCreate",
			Handler:    _FinanceService_PaymentCreate_Handler,
		},
		{
			MethodName: "PaymentGet",
			Handler:    _FinanceService_PaymentGet_Handler,
		},
		{
			MethodName: "PaymentList",
			Handler:    _FinanceService_PaymentList_Handler,
		},
		{
			MethodName: "PaymentSearchList",
			Handler:    _FinanceService_PaymentSearchList_Handler,
		},
		{
			MethodName: "PaymentUpdate",
			Handler:    _FinanceService_PaymentUpdate_Handler,
		},
		{
			MethodName: "PaymentDelete",
			Handler:    _FinanceService_PaymentDelete_Handler,
		},
		{
			MethodName: "Profit",
			Handler:    _FinanceService_Profit_Handler,
		},
		{
			MethodName: "SalaryFinanceCreate",
			Handler:    _FinanceService_SalaryFinanceCreate_Handler,
		},
		{
			MethodName: "SalaryFinanceGet",
			Handler:    _FinanceService_SalaryFinanceGet_Handler,
		},
		{
			MethodName: "SpendingCreate",
			Handler:    _FinanceService_SpendingCreate_Handler,
		},
		{
			MethodName: "SpendingGet",
			Handler:    _FinanceService_SpendingGet_Handler,
		},
		{
			MethodName: "SpendingList",
			Handler:    _FinanceService_SpendingList_Handler,
		},
		{
			MethodName: "SpendingUpdate",
			Handler:    _FinanceService_SpendingUpdate_Handler,
		},
		{
			MethodName: "SpendingDelete",
			Handler:    _FinanceService_SpendingDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

func (m *EmptyRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmptyRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *EmptyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmptyReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SalaryTypeId) > 0 {
		i -= len(m.SalaryTypeId)
		copy(dAtA[i:], m.SalaryTypeId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.SalaryTypeId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PersonalId) > 0 {
		i -= len(m.PersonalId)
		copy(dAtA[i:], m.PersonalId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.PersonalId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Category) > 0 {
		i -= len(m.Category)
		copy(dAtA[i:], m.Category)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Category)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x4a
	}
	if m.PrepaidExpense != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PrepaidExpense))))
		i--
		dAtA[i] = 0x45
	}
	if m.Surcharge != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Surcharge))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Debt != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Debt))))
		i--
		dAtA[i] = 0x35
	}
	if len(m.Given) > 0 {
		for iNdEx := len(m.Given) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Given[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SalaryMonth) > 0 {
		i -= len(m.SalaryMonth)
		copy(dAtA[i:], m.SalaryMonth)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.SalaryMonth)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Salary) > 0 {
		for iNdEx := len(m.Salary) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Salary[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Spending) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Spending) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Spending) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SpendingTypeId) > 0 {
		i -= len(m.SpendingTypeId)
		copy(dAtA[i:], m.SpendingTypeId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.SpendingTypeId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BranchId) > 0 {
		i -= len(m.BranchId)
		copy(dAtA[i:], m.BranchId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.BranchId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PysysId) > 0 {
		i -= len(m.PysysId)
		copy(dAtA[i:], m.PysysId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.PysysId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *By) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *By) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *By) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ByP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ByP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ByP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TeacherName) > 0 {
		i -= len(m.TeacherName)
		copy(dAtA[i:], m.TeacherName)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.TeacherName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TeacherId) > 0 {
		i -= len(m.TeacherId)
		copy(dAtA[i:], m.TeacherId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.TeacherId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendingResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendingResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendingResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x42
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SpendingType != nil {
		{
			size, err := m.SpendingType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Pysys != nil {
		{
			size, err := m.Pysys.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Payment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DirectionId) > 0 {
		i -= len(m.DirectionId)
		copy(dAtA[i:], m.DirectionId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.DirectionId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.StudentId) > 0 {
		i -= len(m.StudentId)
		copy(dAtA[i:], m.StudentId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.StudentId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PysysId) > 0 {
		i -= len(m.PysysId)
		copy(dAtA[i:], m.PysysId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.PysysId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Duration) > 0 {
		i -= len(m.Duration)
		copy(dAtA[i:], m.Duration)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Duration)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PaymentResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x4a
	}
	if m.GroupId != nil {
		{
			size, err := m.GroupId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.DirectionId != nil {
		{
			size, err := m.DirectionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.StudentId != nil {
		{
			size, err := m.StudentId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.PysysId != nil {
		{
			size, err := m.PysysId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Duration) > 0 {
		i -= len(m.Duration)
		copy(dAtA[i:], m.Duration)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Duration)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PaymentListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Payments) > 0 {
		for iNdEx := len(m.Payments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpendingListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendingListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendingListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Spendings) > 0 {
		for iNdEx := len(m.Spendings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spendings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Searching) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Searching) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Searching) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sum != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Sum))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Debt != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Debt))))
		i--
		dAtA[i] = 0x25
	}
	if m.Paid != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Paid))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Amount != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Amount))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PaymentSearchResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentSearchResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentSearchResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Searching) > 0 {
		for iNdEx := len(m.Searching) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Searching[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Sum != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Sum))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *ProfitResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfitResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProfitResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Count))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProfitRespList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfitRespList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProfitRespList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Direction) > 0 {
		for iNdEx := len(m.Direction) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Direction[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Count != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Count))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *ByIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ByIdReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ByIdReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.Page != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpendingListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendingListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendingListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Gacha) > 0 {
		i -= len(m.Gacha)
		copy(dAtA[i:], m.Gacha)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Gacha)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Dan) > 0 {
		i -= len(m.Dan)
		copy(dAtA[i:], m.Dan)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Dan)))
		i--
		dAtA[i] = 0x22
	}
	if m.Limit != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if m.Page != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SpendingType) > 0 {
		i -= len(m.SpendingType)
		copy(dAtA[i:], m.SpendingType)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.SpendingType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendingListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendingListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendingListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Gacha) > 0 {
		i -= len(m.Gacha)
		copy(dAtA[i:], m.Gacha)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Gacha)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Dan) > 0 {
		i -= len(m.Dan)
		copy(dAtA[i:], m.Dan)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Dan)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Limit != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.Page != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PaymentSearchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentSearchReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentSearchReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Gacha) > 0 {
		i -= len(m.Gacha)
		copy(dAtA[i:], m.Gacha)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Gacha)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Dan) > 0 {
		i -= len(m.Dan)
		copy(dAtA[i:], m.Dan)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Dan)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Gacha) > 0 {
		i -= len(m.Gacha)
		copy(dAtA[i:], m.Gacha)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Gacha)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Dan) > 0 {
		i -= len(m.Dan)
		copy(dAtA[i:], m.Dan)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Dan)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Search) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Search) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Search) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TotalAmount) > 0 {
		i -= len(m.TotalAmount)
		copy(dAtA[i:], m.TotalAmount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.TotalAmount)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Debt) > 0 {
		i -= len(m.Debt)
		copy(dAtA[i:], m.Debt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Debt)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Paid) > 0 {
		i -= len(m.Paid)
		copy(dAtA[i:], m.Paid)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Paid)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CountStudent != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.CountStudent))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TeacherName) > 0 {
		i -= len(m.TeacherName)
		copy(dAtA[i:], m.TeacherName)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.TeacherName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Sum) > 0 {
		i -= len(m.Sum)
		copy(dAtA[i:], m.Sum)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Sum)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Search) > 0 {
		for iNdEx := len(m.Search) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Search[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Tesh) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tesh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tesh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Given) > 0 {
		i -= len(m.Given)
		copy(dAtA[i:], m.Given)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Given)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Count) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Count) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Count) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFinance(dAtA []byte, offset int, v uint64) int {
	offset -= sovFinance(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EmptyRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EmptyReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.PersonalId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.SalaryTypeId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.SalaryMonth)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if len(m.Given) > 0 {
		for _, e := range m.Given {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.Debt != 0 {
		n += 5
	}
	if m.Surcharge != 0 {
		n += 5
	}
	if m.PrepaidExpense != 0 {
		n += 5
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Salary) > 0 {
		for _, e := range m.Salary {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovFinance(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Spending) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.PysysId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.BranchId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.SpendingTypeId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *By) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ByP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.TeacherId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.TeacherName)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpendingResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Pysys != nil {
		l = m.Pysys.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.SpendingType != nil {
		l = m.SpendingType.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Payment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.PysysId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.StudentId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.DirectionId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.PysysId != nil {
		l = m.PysysId.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.StudentId != nil {
		l = m.StudentId.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.DirectionId != nil {
		l = m.DirectionId.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.GroupId != nil {
		l = m.GroupId.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Payments) > 0 {
		for _, e := range m.Payments {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovFinance(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpendingListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Spendings) > 0 {
		for _, e := range m.Spendings {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovFinance(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Searching) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Amount != 0 {
		n += 5
	}
	if m.Paid != 0 {
		n += 5
	}
	if m.Debt != 0 {
		n += 5
	}
	if m.Sum != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentSearchResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != 0 {
		n += 5
	}
	if len(m.Searching) > 0 {
		for _, e := range m.Searching {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProfitResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Count != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProfitRespList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 5
	}
	if len(m.Direction) > 0 {
		for _, e := range m.Direction {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ByIdReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovFinance(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovFinance(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpendingListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpendingType)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovFinance(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovFinance(uint64(m.Limit))
	}
	l = len(m.Dan)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Gacha)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpendingListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovFinance(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovFinance(uint64(m.Limit))
	}
	l = len(m.Dan)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Gacha)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentSearchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Dan)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Gacha)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Dan)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Gacha)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Search) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.TeacherName)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.CountStudent != 0 {
		n += 1 + sovFinance(uint64(m.CountStudent))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Paid)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Debt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.TotalAmount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Search) > 0 {
		for _, e := range m.Search {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	l = len(m.Sum)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tesh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Given)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Count) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovFinance(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFinance(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFinance(x uint64) (n int) {
	return sovFinance(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EmptyRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmptyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SalaryTypeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SalaryTypeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SalaryMonth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SalaryMonth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Given", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Given = append(m.Given, &Tesh{})
			if err := m.Given[len(m.Given)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Debt = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Surcharge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Surcharge = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepaidExpense", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PrepaidExpense = float32(math.Float32frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salary = append(m.Salary, &Response{})
			if err := m.Salary[len(m.Salary)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Spending) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spending: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spending: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PysysId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PysysId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BranchId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendingTypeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpendingTypeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *By) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: By: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: By: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ByP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ByP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ByP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeacherId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeacherId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeacherName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeacherName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendingResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendingResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendingResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pysys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pysys == nil {
				m.Pysys = &By{}
			}
			if err := m.Pysys.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendingType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpendingType == nil {
				m.SpendingType = &By{}
			}
			if err := m.SpendingType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &By{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PysysId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PysysId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PysysId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PysysId == nil {
				m.PysysId = &By{}
			}
			if err := m.PysysId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StudentId == nil {
				m.StudentId = &By{}
			}
			if err := m.StudentId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DirectionId == nil {
				m.DirectionId = &By{}
			}
			if err := m.DirectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupId == nil {
				m.GroupId = &ByP{}
			}
			if err := m.GroupId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payments = append(m.Payments, &PaymentResp{})
			if err := m.Payments[len(m.Payments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendingListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendingListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendingListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spendings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spendings = append(m.Spendings, &SpendingResp{})
			if err := m.Spendings[len(m.Spendings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Searching) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Searching: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Searching: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Amount = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paid", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Paid = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Debt = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Sum = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentSearchResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentSearchResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentSearchResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Sum = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Searching", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Searching = append(m.Searching, &Searching{})
			if err := m.Searching[len(m.Searching)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfitResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfitResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfitResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Count = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfitRespList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfitRespList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfitRespList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Count = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = append(m.Direction, &ProfitResp{})
			if err := m.Direction[len(m.Direction)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ByIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ByIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ByIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendingListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendingListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendingListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendingType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpendingType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gacha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gacha = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendingListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendingListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendingListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gacha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gacha = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentSearchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentSearchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentSearchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gacha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gacha = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gacha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gacha = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Search) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Search: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Search: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeacherName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeacherName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountStudent", wireType)
			}
			m.CountStudent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountStudent |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Debt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Search = append(m.Search, &Search{})
			if err := m.Search[len(m.Search)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tesh) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tesh: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tesh: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Given", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Given = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Count) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Count: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Count: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFinance(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFinance
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFinance
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFinance
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFinance        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFinance          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFinance = fmt.Errorf("proto: unexpected end of group")
)
