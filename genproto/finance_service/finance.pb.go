// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: finance.proto

package finance_service

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EmptyRes struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmptyRes) Reset()         { *m = EmptyRes{} }
func (m *EmptyRes) String() string { return proto.CompactTextString(m) }
func (*EmptyRes) ProtoMessage()    {}
func (*EmptyRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{0}
}
func (m *EmptyRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmptyRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmptyRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyRes.Merge(m, src)
}
func (m *EmptyRes) XXX_Size() int {
	return m.Size()
}
func (m *EmptyRes) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyRes.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyRes proto.InternalMessageInfo

type EmptyReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Category             string   `protobuf:"bytes,2,opt,name=category,proto3" json:"category"`
	PersonalId           string   `protobuf:"bytes,3,opt,name=personal_id,json=personalId,proto3" json:"personal_id"`
	SalaryTypeId         string   `protobuf:"bytes,4,opt,name=salary_type_id,json=salaryTypeId,proto3" json:"salary_type_id"`
	Amount               string   `protobuf:"bytes,5,opt,name=amount,proto3" json:"amount"`
	Comment              string   `protobuf:"bytes,6,opt,name=comment,proto3" json:"comment"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmptyReq) Reset()         { *m = EmptyReq{} }
func (m *EmptyReq) String() string { return proto.CompactTextString(m) }
func (*EmptyReq) ProtoMessage()    {}
func (*EmptyReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{1}
}
func (m *EmptyReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmptyReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmptyReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyReq.Merge(m, src)
}
func (m *EmptyReq) XXX_Size() int {
	return m.Size()
}
func (m *EmptyReq) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyReq.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyReq proto.InternalMessageInfo

func (m *EmptyReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *EmptyReq) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

func (m *EmptyReq) GetPersonalId() string {
	if m != nil {
		return m.PersonalId
	}
	return ""
}

func (m *EmptyReq) GetSalaryTypeId() string {
	if m != nil {
		return m.SalaryTypeId
	}
	return ""
}

func (m *EmptyReq) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *EmptyReq) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

type Status struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	PersonalId           string   `protobuf:"bytes,2,opt,name=personal_id,json=personalId,proto3" json:"personal_id"`
	Status               string   `protobuf:"bytes,3,opt,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{2}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Status) GetPersonalId() string {
	if m != nil {
		return m.PersonalId
	}
	return ""
}

func (m *Status) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type StatusReq struct {
	Status               []*Status `protobuf:"bytes,1,rep,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *StatusReq) Reset()         { *m = StatusReq{} }
func (m *StatusReq) String() string { return proto.CompactTextString(m) }
func (*StatusReq) ProtoMessage()    {}
func (*StatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{3}
}
func (m *StatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusReq.Merge(m, src)
}
func (m *StatusReq) XXX_Size() int {
	return m.Size()
}
func (m *StatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_StatusReq proto.InternalMessageInfo

func (m *StatusReq) GetStatus() []*Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type PySt struct {
	StudentId            string   `protobuf:"bytes,1,opt,name=student_id,json=studentId,proto3" json:"student_id"`
	GroupId              string   `protobuf:"bytes,2,opt,name=group_id,json=groupId,proto3" json:"group_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PySt) Reset()         { *m = PySt{} }
func (m *PySt) String() string { return proto.CompactTextString(m) }
func (*PySt) ProtoMessage()    {}
func (*PySt) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{4}
}
func (m *PySt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PySt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PySt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PySt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PySt.Merge(m, src)
}
func (m *PySt) XXX_Size() int {
	return m.Size()
}
func (m *PySt) XXX_DiscardUnknown() {
	xxx_messageInfo_PySt.DiscardUnknown(m)
}

var xxx_messageInfo_PySt proto.InternalMessageInfo

func (m *PySt) GetStudentId() string {
	if m != nil {
		return m.StudentId
	}
	return ""
}

func (m *PySt) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

type StatusSpending struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Status               string   `protobuf:"bytes,2,opt,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StatusSpending) Reset()         { *m = StatusSpending{} }
func (m *StatusSpending) String() string { return proto.CompactTextString(m) }
func (*StatusSpending) ProtoMessage()    {}
func (*StatusSpending) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{5}
}
func (m *StatusSpending) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusSpending) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusSpending.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusSpending) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusSpending.Merge(m, src)
}
func (m *StatusSpending) XXX_Size() int {
	return m.Size()
}
func (m *StatusSpending) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusSpending.DiscardUnknown(m)
}

var xxx_messageInfo_StatusSpending proto.InternalMessageInfo

func (m *StatusSpending) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StatusSpending) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type StatusSpendingReq struct {
	Status               []*StatusSpending `protobuf:"bytes,1,rep,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *StatusSpendingReq) Reset()         { *m = StatusSpendingReq{} }
func (m *StatusSpendingReq) String() string { return proto.CompactTextString(m) }
func (*StatusSpendingReq) ProtoMessage()    {}
func (*StatusSpendingReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{6}
}
func (m *StatusSpendingReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusSpendingReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusSpendingReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusSpendingReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusSpendingReq.Merge(m, src)
}
func (m *StatusSpendingReq) XXX_Size() int {
	return m.Size()
}
func (m *StatusSpendingReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusSpendingReq.DiscardUnknown(m)
}

var xxx_messageInfo_StatusSpendingReq proto.InternalMessageInfo

func (m *StatusSpendingReq) GetStatus() []*StatusSpending {
	if m != nil {
		return m.Status
	}
	return nil
}

type Empty struct {
	Status               bool     `protobuf:"varint,1,opt,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{7}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

func (m *Empty) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type Request struct {
	Date                 string   `protobuf:"bytes,1,opt,name=date,proto3" json:"date"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{8}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

type Response struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Permission           string   `protobuf:"bytes,3,opt,name=permission,proto3" json:"permission"`
	SalaryMonth          string   `protobuf:"bytes,4,opt,name=salary_month,json=salaryMonth,proto3" json:"salary_month"`
	Given                []*Tesh  `protobuf:"bytes,5,rep,name=given,proto3" json:"given"`
	Debt                 float64  `protobuf:"fixed64,6,opt,name=debt,proto3" json:"debt"`
	Comment              string   `protobuf:"bytes,7,opt,name=comment,proto3" json:"comment"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{9}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Response) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Response) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

func (m *Response) GetSalaryMonth() string {
	if m != nil {
		return m.SalaryMonth
	}
	return ""
}

func (m *Response) GetGiven() []*Tesh {
	if m != nil {
		return m.Given
	}
	return nil
}

func (m *Response) GetDebt() float64 {
	if m != nil {
		return m.Debt
	}
	return 0
}

func (m *Response) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

type ResponseList struct {
	Salary               []*Response `protobuf:"bytes,1,rep,name=salary,proto3" json:"salary"`
	Count                int64       `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ResponseList) Reset()         { *m = ResponseList{} }
func (m *ResponseList) String() string { return proto.CompactTextString(m) }
func (*ResponseList) ProtoMessage()    {}
func (*ResponseList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{10}
}
func (m *ResponseList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseList.Merge(m, src)
}
func (m *ResponseList) XXX_Size() int {
	return m.Size()
}
func (m *ResponseList) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseList.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseList proto.InternalMessageInfo

func (m *ResponseList) GetSalary() []*Response {
	if m != nil {
		return m.Salary
	}
	return nil
}

func (m *ResponseList) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type Spending struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Amount               string   `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
	Comment              string   `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment"`
	Status               string   `protobuf:"bytes,4,opt,name=status,proto3" json:"status"`
	PysysId              string   `protobuf:"bytes,5,opt,name=pysys_id,json=pysysId,proto3" json:"pysys_id"`
	BranchId             string   `protobuf:"bytes,6,opt,name=branch_id,json=branchId,proto3" json:"branch_id"`
	SpendingTypeId       string   `protobuf:"bytes,7,opt,name=spending_type_id,json=spendingTypeId,proto3" json:"spending_type_id"`
	CreatedAt            string   `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Spending) Reset()         { *m = Spending{} }
func (m *Spending) String() string { return proto.CompactTextString(m) }
func (*Spending) ProtoMessage()    {}
func (*Spending) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{11}
}
func (m *Spending) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Spending) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Spending.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Spending) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Spending.Merge(m, src)
}
func (m *Spending) XXX_Size() int {
	return m.Size()
}
func (m *Spending) XXX_DiscardUnknown() {
	xxx_messageInfo_Spending.DiscardUnknown(m)
}

var xxx_messageInfo_Spending proto.InternalMessageInfo

func (m *Spending) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Spending) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Spending) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Spending) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Spending) GetPysysId() string {
	if m != nil {
		return m.PysysId
	}
	return ""
}

func (m *Spending) GetBranchId() string {
	if m != nil {
		return m.BranchId
	}
	return ""
}

func (m *Spending) GetSpendingTypeId() string {
	if m != nil {
		return m.SpendingTypeId
	}
	return ""
}

func (m *Spending) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *Spending) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type By struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *By) Reset()         { *m = By{} }
func (m *By) String() string { return proto.CompactTextString(m) }
func (*By) ProtoMessage()    {}
func (*By) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{12}
}
func (m *By) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *By) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_By.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *By) XXX_Merge(src proto.Message) {
	xxx_messageInfo_By.Merge(m, src)
}
func (m *By) XXX_Size() int {
	return m.Size()
}
func (m *By) XXX_DiscardUnknown() {
	xxx_messageInfo_By.DiscardUnknown(m)
}

var xxx_messageInfo_By proto.InternalMessageInfo

func (m *By) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *By) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ByP struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	TeacherId            string   `protobuf:"bytes,3,opt,name=teacher_id,json=teacherId,proto3" json:"teacher_id"`
	TeacherName          string   `protobuf:"bytes,4,opt,name=teacher_name,json=teacherName,proto3" json:"teacher_name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ByP) Reset()         { *m = ByP{} }
func (m *ByP) String() string { return proto.CompactTextString(m) }
func (*ByP) ProtoMessage()    {}
func (*ByP) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{13}
}
func (m *ByP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ByP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ByP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ByP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ByP.Merge(m, src)
}
func (m *ByP) XXX_Size() int {
	return m.Size()
}
func (m *ByP) XXX_DiscardUnknown() {
	xxx_messageInfo_ByP.DiscardUnknown(m)
}

var xxx_messageInfo_ByP proto.InternalMessageInfo

func (m *ByP) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ByP) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ByP) GetTeacherId() string {
	if m != nil {
		return m.TeacherId
	}
	return ""
}

func (m *ByP) GetTeacherName() string {
	if m != nil {
		return m.TeacherName
	}
	return ""
}

type SpendingResp struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Amount               string   `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
	Comment              string   `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment"`
	Status               string   `protobuf:"bytes,4,opt,name=status,proto3" json:"status"`
	Pysys                *By      `protobuf:"bytes,5,opt,name=pysys,proto3" json:"pysys"`
	SpendingType         *By      `protobuf:"bytes,6,opt,name=spending_type,json=spendingType,proto3" json:"spending_type"`
	Branch               *By      `protobuf:"bytes,7,opt,name=branch,proto3" json:"branch"`
	CreatedAt            string   `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpendingResp) Reset()         { *m = SpendingResp{} }
func (m *SpendingResp) String() string { return proto.CompactTextString(m) }
func (*SpendingResp) ProtoMessage()    {}
func (*SpendingResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{14}
}
func (m *SpendingResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendingResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendingResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendingResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendingResp.Merge(m, src)
}
func (m *SpendingResp) XXX_Size() int {
	return m.Size()
}
func (m *SpendingResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendingResp.DiscardUnknown(m)
}

var xxx_messageInfo_SpendingResp proto.InternalMessageInfo

func (m *SpendingResp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SpendingResp) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *SpendingResp) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *SpendingResp) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *SpendingResp) GetPysys() *By {
	if m != nil {
		return m.Pysys
	}
	return nil
}

func (m *SpendingResp) GetSpendingType() *By {
	if m != nil {
		return m.SpendingType
	}
	return nil
}

func (m *SpendingResp) GetBranch() *By {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *SpendingResp) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *SpendingResp) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type Payment struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Amount               string   `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
	Type                 string   `protobuf:"bytes,3,opt,name=type,proto3" json:"type"`
	Duration             string   `protobuf:"bytes,4,opt,name=duration,proto3" json:"duration"`
	PysysId              string   `protobuf:"bytes,5,opt,name=pysys_id,json=pysysId,proto3" json:"pysys_id"`
	StudentId            string   `protobuf:"bytes,6,opt,name=student_id,json=studentId,proto3" json:"student_id"`
	DirectionId          string   `protobuf:"bytes,7,opt,name=direction_id,json=directionId,proto3" json:"direction_id"`
	GroupId              string   `protobuf:"bytes,8,opt,name=group_id,json=groupId,proto3" json:"group_id"`
	CreatedAt            string   `protobuf:"bytes,9,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,10,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Payment) Reset()         { *m = Payment{} }
func (m *Payment) String() string { return proto.CompactTextString(m) }
func (*Payment) ProtoMessage()    {}
func (*Payment) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{15}
}
func (m *Payment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payment.Merge(m, src)
}
func (m *Payment) XXX_Size() int {
	return m.Size()
}
func (m *Payment) XXX_DiscardUnknown() {
	xxx_messageInfo_Payment.DiscardUnknown(m)
}

var xxx_messageInfo_Payment proto.InternalMessageInfo

func (m *Payment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Payment) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Payment) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Payment) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

func (m *Payment) GetPysysId() string {
	if m != nil {
		return m.PysysId
	}
	return ""
}

func (m *Payment) GetStudentId() string {
	if m != nil {
		return m.StudentId
	}
	return ""
}

func (m *Payment) GetDirectionId() string {
	if m != nil {
		return m.DirectionId
	}
	return ""
}

func (m *Payment) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *Payment) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *Payment) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type PaymentResp struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Amount               string   `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
	Type                 string   `protobuf:"bytes,3,opt,name=type,proto3" json:"type"`
	Duration             string   `protobuf:"bytes,4,opt,name=duration,proto3" json:"duration"`
	PysysId              *By      `protobuf:"bytes,5,opt,name=pysys_id,json=pysysId,proto3" json:"pysys_id"`
	StudentId            *By      `protobuf:"bytes,6,opt,name=student_id,json=studentId,proto3" json:"student_id"`
	DirectionId          *By      `protobuf:"bytes,7,opt,name=direction_id,json=directionId,proto3" json:"direction_id"`
	GroupId              *ByP     `protobuf:"bytes,8,opt,name=group_id,json=groupId,proto3" json:"group_id"`
	CreatedAt            string   `protobuf:"bytes,9,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,10,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PaymentResp) Reset()         { *m = PaymentResp{} }
func (m *PaymentResp) String() string { return proto.CompactTextString(m) }
func (*PaymentResp) ProtoMessage()    {}
func (*PaymentResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{16}
}
func (m *PaymentResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentResp.Merge(m, src)
}
func (m *PaymentResp) XXX_Size() int {
	return m.Size()
}
func (m *PaymentResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentResp.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentResp proto.InternalMessageInfo

func (m *PaymentResp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PaymentResp) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *PaymentResp) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PaymentResp) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

func (m *PaymentResp) GetPysysId() *By {
	if m != nil {
		return m.PysysId
	}
	return nil
}

func (m *PaymentResp) GetStudentId() *By {
	if m != nil {
		return m.StudentId
	}
	return nil
}

func (m *PaymentResp) GetDirectionId() *By {
	if m != nil {
		return m.DirectionId
	}
	return nil
}

func (m *PaymentResp) GetGroupId() *ByP {
	if m != nil {
		return m.GroupId
	}
	return nil
}

func (m *PaymentResp) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *PaymentResp) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type PaymentListResp struct {
	Payments             []*PaymentResp `protobuf:"bytes,1,rep,name=payments,proto3" json:"payments"`
	Count                int64          `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PaymentListResp) Reset()         { *m = PaymentListResp{} }
func (m *PaymentListResp) String() string { return proto.CompactTextString(m) }
func (*PaymentListResp) ProtoMessage()    {}
func (*PaymentListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{17}
}
func (m *PaymentListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentListResp.Merge(m, src)
}
func (m *PaymentListResp) XXX_Size() int {
	return m.Size()
}
func (m *PaymentListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentListResp.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentListResp proto.InternalMessageInfo

func (m *PaymentListResp) GetPayments() []*PaymentResp {
	if m != nil {
		return m.Payments
	}
	return nil
}

func (m *PaymentListResp) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type SpendingListResp struct {
	Spendings            []*SpendingResp `protobuf:"bytes,1,rep,name=spendings,proto3" json:"spendings"`
	Count                string          `protobuf:"bytes,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SpendingListResp) Reset()         { *m = SpendingListResp{} }
func (m *SpendingListResp) String() string { return proto.CompactTextString(m) }
func (*SpendingListResp) ProtoMessage()    {}
func (*SpendingListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{18}
}
func (m *SpendingListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendingListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendingListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendingListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendingListResp.Merge(m, src)
}
func (m *SpendingListResp) XXX_Size() int {
	return m.Size()
}
func (m *SpendingListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendingListResp.DiscardUnknown(m)
}

var xxx_messageInfo_SpendingListResp proto.InternalMessageInfo

func (m *SpendingListResp) GetSpendings() []*SpendingResp {
	if m != nil {
		return m.Spendings
	}
	return nil
}

func (m *SpendingListResp) GetCount() string {
	if m != nil {
		return m.Count
	}
	return ""
}

type Searching struct {
	Student              *By      `protobuf:"bytes,1,opt,name=student,proto3" json:"student"`
	Duration             string   `protobuf:"bytes,2,opt,name=duration,proto3" json:"duration"`
	Pysys                string   `protobuf:"bytes,3,opt,name=pysys,proto3" json:"pysys"`
	Paid                 float64  `protobuf:"fixed64,4,opt,name=paid,proto3" json:"paid"`
	Debt                 float64  `protobuf:"fixed64,5,opt,name=debt,proto3" json:"debt"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Searching) Reset()         { *m = Searching{} }
func (m *Searching) String() string { return proto.CompactTextString(m) }
func (*Searching) ProtoMessage()    {}
func (*Searching) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{19}
}
func (m *Searching) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Searching) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Searching.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Searching) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Searching.Merge(m, src)
}
func (m *Searching) XXX_Size() int {
	return m.Size()
}
func (m *Searching) XXX_DiscardUnknown() {
	xxx_messageInfo_Searching.DiscardUnknown(m)
}

var xxx_messageInfo_Searching proto.InternalMessageInfo

func (m *Searching) GetStudent() *By {
	if m != nil {
		return m.Student
	}
	return nil
}

func (m *Searching) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

func (m *Searching) GetPysys() string {
	if m != nil {
		return m.Pysys
	}
	return ""
}

func (m *Searching) GetPaid() float64 {
	if m != nil {
		return m.Paid
	}
	return 0
}

func (m *Searching) GetDebt() float64 {
	if m != nil {
		return m.Debt
	}
	return 0
}

type PaymentSearchResp struct {
	Group                *By          `protobuf:"bytes,1,opt,name=group,proto3" json:"group"`
	Searching            []*Searching `protobuf:"bytes,2,rep,name=searching,proto3" json:"searching"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PaymentSearchResp) Reset()         { *m = PaymentSearchResp{} }
func (m *PaymentSearchResp) String() string { return proto.CompactTextString(m) }
func (*PaymentSearchResp) ProtoMessage()    {}
func (*PaymentSearchResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{20}
}
func (m *PaymentSearchResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentSearchResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentSearchResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentSearchResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentSearchResp.Merge(m, src)
}
func (m *PaymentSearchResp) XXX_Size() int {
	return m.Size()
}
func (m *PaymentSearchResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentSearchResp.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentSearchResp proto.InternalMessageInfo

func (m *PaymentSearchResp) GetGroup() *By {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *PaymentSearchResp) GetSearching() []*Searching {
	if m != nil {
		return m.Searching
	}
	return nil
}

type ProfitResp struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	Count                float32  `protobuf:"fixed32,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProfitResp) Reset()         { *m = ProfitResp{} }
func (m *ProfitResp) String() string { return proto.CompactTextString(m) }
func (*ProfitResp) ProtoMessage()    {}
func (*ProfitResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{21}
}
func (m *ProfitResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfitResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfitResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProfitResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfitResp.Merge(m, src)
}
func (m *ProfitResp) XXX_Size() int {
	return m.Size()
}
func (m *ProfitResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfitResp.DiscardUnknown(m)
}

var xxx_messageInfo_ProfitResp proto.InternalMessageInfo

func (m *ProfitResp) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProfitResp) GetCount() float32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type ProfitRespList struct {
	Count                float32       `protobuf:"fixed32,1,opt,name=count,proto3" json:"count"`
	Direction            []*ProfitResp `protobuf:"bytes,2,rep,name=direction,proto3" json:"direction"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ProfitRespList) Reset()         { *m = ProfitRespList{} }
func (m *ProfitRespList) String() string { return proto.CompactTextString(m) }
func (*ProfitRespList) ProtoMessage()    {}
func (*ProfitRespList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{22}
}
func (m *ProfitRespList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfitRespList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfitRespList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProfitRespList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfitRespList.Merge(m, src)
}
func (m *ProfitRespList) XXX_Size() int {
	return m.Size()
}
func (m *ProfitRespList) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfitRespList.DiscardUnknown(m)
}

var xxx_messageInfo_ProfitRespList proto.InternalMessageInfo

func (m *ProfitRespList) GetCount() float32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ProfitRespList) GetDirection() []*ProfitResp {
	if m != nil {
		return m.Direction
	}
	return nil
}

type ByIdReq struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ByIdReq) Reset()         { *m = ByIdReq{} }
func (m *ByIdReq) String() string { return proto.CompactTextString(m) }
func (*ByIdReq) ProtoMessage()    {}
func (*ByIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{23}
}
func (m *ByIdReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ByIdReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ByIdReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ByIdReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ByIdReq.Merge(m, src)
}
func (m *ByIdReq) XXX_Size() int {
	return m.Size()
}
func (m *ByIdReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ByIdReq.DiscardUnknown(m)
}

var xxx_messageInfo_ByIdReq proto.InternalMessageInfo

func (m *ByIdReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type ListReq struct {
	Page                 int64    `protobuf:"varint,1,opt,name=page,proto3" json:"page"`
	Limit                int64    `protobuf:"varint,2,opt,name=limit,proto3" json:"limit"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListReq) Reset()         { *m = ListReq{} }
func (m *ListReq) String() string { return proto.CompactTextString(m) }
func (*ListReq) ProtoMessage()    {}
func (*ListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{24}
}
func (m *ListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListReq.Merge(m, src)
}
func (m *ListReq) XXX_Size() int {
	return m.Size()
}
func (m *ListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListReq proto.InternalMessageInfo

func (m *ListReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ListReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type SpendingListReq struct {
	SpendingType         string   `protobuf:"bytes,1,opt,name=spending_type,json=spendingType,proto3" json:"spending_type"`
	Page                 int64    `protobuf:"varint,2,opt,name=page,proto3" json:"page"`
	Limit                int64    `protobuf:"varint,3,opt,name=limit,proto3" json:"limit"`
	Dan                  string   `protobuf:"bytes,4,opt,name=dan,proto3" json:"dan"`
	Gacha                string   `protobuf:"bytes,5,opt,name=gacha,proto3" json:"gacha"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpendingListReq) Reset()         { *m = SpendingListReq{} }
func (m *SpendingListReq) String() string { return proto.CompactTextString(m) }
func (*SpendingListReq) ProtoMessage()    {}
func (*SpendingListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{25}
}
func (m *SpendingListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendingListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendingListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendingListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendingListReq.Merge(m, src)
}
func (m *SpendingListReq) XXX_Size() int {
	return m.Size()
}
func (m *SpendingListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendingListReq.DiscardUnknown(m)
}

var xxx_messageInfo_SpendingListReq proto.InternalMessageInfo

func (m *SpendingListReq) GetSpendingType() string {
	if m != nil {
		return m.SpendingType
	}
	return ""
}

func (m *SpendingListReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *SpendingListReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SpendingListReq) GetDan() string {
	if m != nil {
		return m.Dan
	}
	return ""
}

func (m *SpendingListReq) GetGacha() string {
	if m != nil {
		return m.Gacha
	}
	return ""
}

type SpendingListRequest struct {
	Page                 int64    `protobuf:"varint,1,opt,name=page,proto3" json:"page"`
	Limit                int64    `protobuf:"varint,2,opt,name=limit,proto3" json:"limit"`
	Dan                  string   `protobuf:"bytes,3,opt,name=dan,proto3" json:"dan"`
	Gacha                string   `protobuf:"bytes,4,opt,name=gacha,proto3" json:"gacha"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpendingListRequest) Reset()         { *m = SpendingListRequest{} }
func (m *SpendingListRequest) String() string { return proto.CompactTextString(m) }
func (*SpendingListRequest) ProtoMessage()    {}
func (*SpendingListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{26}
}
func (m *SpendingListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendingListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendingListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendingListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendingListRequest.Merge(m, src)
}
func (m *SpendingListRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpendingListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendingListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpendingListRequest proto.InternalMessageInfo

func (m *SpendingListRequest) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *SpendingListRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SpendingListRequest) GetDan() string {
	if m != nil {
		return m.Dan
	}
	return ""
}

func (m *SpendingListRequest) GetGacha() string {
	if m != nil {
		return m.Gacha
	}
	return ""
}

type PaymentSearchReq struct {
	Dan                  string   `protobuf:"bytes,1,opt,name=dan,proto3" json:"dan"`
	Gacha                string   `protobuf:"bytes,2,opt,name=gacha,proto3" json:"gacha"`
	Id                   string   `protobuf:"bytes,3,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PaymentSearchReq) Reset()         { *m = PaymentSearchReq{} }
func (m *PaymentSearchReq) String() string { return proto.CompactTextString(m) }
func (*PaymentSearchReq) ProtoMessage()    {}
func (*PaymentSearchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{27}
}
func (m *PaymentSearchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentSearchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentSearchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentSearchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentSearchReq.Merge(m, src)
}
func (m *PaymentSearchReq) XXX_Size() int {
	return m.Size()
}
func (m *PaymentSearchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentSearchReq.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentSearchReq proto.InternalMessageInfo

func (m *PaymentSearchReq) GetDan() string {
	if m != nil {
		return m.Dan
	}
	return ""
}

func (m *PaymentSearchReq) GetGacha() string {
	if m != nil {
		return m.Gacha
	}
	return ""
}

func (m *PaymentSearchReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type SearchReq struct {
	Teacher              string   `protobuf:"bytes,1,opt,name=teacher,proto3" json:"teacher"`
	Direction            string   `protobuf:"bytes,2,opt,name=direction,proto3" json:"direction"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchReq) Reset()         { *m = SearchReq{} }
func (m *SearchReq) String() string { return proto.CompactTextString(m) }
func (*SearchReq) ProtoMessage()    {}
func (*SearchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{28}
}
func (m *SearchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchReq.Merge(m, src)
}
func (m *SearchReq) XXX_Size() int {
	return m.Size()
}
func (m *SearchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchReq.DiscardUnknown(m)
}

var xxx_messageInfo_SearchReq proto.InternalMessageInfo

func (m *SearchReq) GetTeacher() string {
	if m != nil {
		return m.Teacher
	}
	return ""
}

func (m *SearchReq) GetDirection() string {
	if m != nil {
		return m.Direction
	}
	return ""
}

type Search struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Teacher              *By      `protobuf:"bytes,3,opt,name=teacher,proto3" json:"teacher"`
	CountStudent         int64    `protobuf:"varint,4,opt,name=countStudent,proto3" json:"countStudent"`
	Amount               float64  `protobuf:"fixed64,5,opt,name=amount,proto3" json:"amount"`
	Pay                  *Pay     `protobuf:"bytes,6,opt,name=pay,proto3" json:"pay"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Search) Reset()         { *m = Search{} }
func (m *Search) String() string { return proto.CompactTextString(m) }
func (*Search) ProtoMessage()    {}
func (*Search) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{29}
}
func (m *Search) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Search) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Search.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Search) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Search.Merge(m, src)
}
func (m *Search) XXX_Size() int {
	return m.Size()
}
func (m *Search) XXX_DiscardUnknown() {
	xxx_messageInfo_Search.DiscardUnknown(m)
}

var xxx_messageInfo_Search proto.InternalMessageInfo

func (m *Search) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Search) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Search) GetTeacher() *By {
	if m != nil {
		return m.Teacher
	}
	return nil
}

func (m *Search) GetCountStudent() int64 {
	if m != nil {
		return m.CountStudent
	}
	return 0
}

func (m *Search) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Search) GetPay() *Pay {
	if m != nil {
		return m.Pay
	}
	return nil
}

type Pay struct {
	Paid                 float64  `protobuf:"fixed64,1,opt,name=paid,proto3" json:"paid"`
	Debt                 float64  `protobuf:"fixed64,2,opt,name=debt,proto3" json:"debt"`
	TotalAmount          float64  `protobuf:"fixed64,3,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pay) Reset()         { *m = Pay{} }
func (m *Pay) String() string { return proto.CompactTextString(m) }
func (*Pay) ProtoMessage()    {}
func (*Pay) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{30}
}
func (m *Pay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pay.Merge(m, src)
}
func (m *Pay) XXX_Size() int {
	return m.Size()
}
func (m *Pay) XXX_DiscardUnknown() {
	xxx_messageInfo_Pay.DiscardUnknown(m)
}

var xxx_messageInfo_Pay proto.InternalMessageInfo

func (m *Pay) GetPaid() float64 {
	if m != nil {
		return m.Paid
	}
	return 0
}

func (m *Pay) GetDebt() float64 {
	if m != nil {
		return m.Debt
	}
	return 0
}

func (m *Pay) GetTotalAmount() float64 {
	if m != nil {
		return m.TotalAmount
	}
	return 0
}

type SearchListResp struct {
	Search               []*Search `protobuf:"bytes,1,rep,name=search,proto3" json:"search"`
	Sum                  float64   `protobuf:"fixed64,2,opt,name=sum,proto3" json:"sum"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SearchListResp) Reset()         { *m = SearchListResp{} }
func (m *SearchListResp) String() string { return proto.CompactTextString(m) }
func (*SearchListResp) ProtoMessage()    {}
func (*SearchListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{31}
}
func (m *SearchListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchListResp.Merge(m, src)
}
func (m *SearchListResp) XXX_Size() int {
	return m.Size()
}
func (m *SearchListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchListResp.DiscardUnknown(m)
}

var xxx_messageInfo_SearchListResp proto.InternalMessageInfo

func (m *SearchListResp) GetSearch() []*Search {
	if m != nil {
		return m.Search
	}
	return nil
}

func (m *SearchListResp) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

type Tesh struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Given                string   `protobuf:"bytes,2,opt,name=given,proto3" json:"given"`
	Date                 string   `protobuf:"bytes,3,opt,name=date,proto3" json:"date"`
	Comment              string   `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment"`
	Status               string   `protobuf:"bytes,5,opt,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tesh) Reset()         { *m = Tesh{} }
func (m *Tesh) String() string { return proto.CompactTextString(m) }
func (*Tesh) ProtoMessage()    {}
func (*Tesh) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{32}
}
func (m *Tesh) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tesh) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tesh.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tesh) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tesh.Merge(m, src)
}
func (m *Tesh) XXX_Size() int {
	return m.Size()
}
func (m *Tesh) XXX_DiscardUnknown() {
	xxx_messageInfo_Tesh.DiscardUnknown(m)
}

var xxx_messageInfo_Tesh proto.InternalMessageInfo

func (m *Tesh) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Tesh) GetGiven() string {
	if m != nil {
		return m.Given
	}
	return ""
}

func (m *Tesh) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *Tesh) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Tesh) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type Count struct {
	Count                int64    `protobuf:"varint,1,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Count) Reset()         { *m = Count{} }
func (m *Count) String() string { return proto.CompactTextString(m) }
func (*Count) ProtoMessage()    {}
func (*Count) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{33}
}
func (m *Count) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Count) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Count.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Count) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Count.Merge(m, src)
}
func (m *Count) XXX_Size() int {
	return m.Size()
}
func (m *Count) XXX_DiscardUnknown() {
	xxx_messageInfo_Count.DiscardUnknown(m)
}

var xxx_messageInfo_Count proto.InternalMessageInfo

func (m *Count) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type PayStd struct {
	Duration             string   `protobuf:"bytes,1,opt,name=duration,proto3" json:"duration"`
	WithDay              string   `protobuf:"bytes,2,opt,name=with_day,json=withDay,proto3" json:"with_day"`
	Amount               string   `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
	Pysys                string   `protobuf:"bytes,4,opt,name=pysys,proto3" json:"pysys"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PayStd) Reset()         { *m = PayStd{} }
func (m *PayStd) String() string { return proto.CompactTextString(m) }
func (*PayStd) ProtoMessage()    {}
func (*PayStd) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{34}
}
func (m *PayStd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayStd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayStd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayStd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayStd.Merge(m, src)
}
func (m *PayStd) XXX_Size() int {
	return m.Size()
}
func (m *PayStd) XXX_DiscardUnknown() {
	xxx_messageInfo_PayStd.DiscardUnknown(m)
}

var xxx_messageInfo_PayStd proto.InternalMessageInfo

func (m *PayStd) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

func (m *PayStd) GetWithDay() string {
	if m != nil {
		return m.WithDay
	}
	return ""
}

func (m *PayStd) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *PayStd) GetPysys() string {
	if m != nil {
		return m.Pysys
	}
	return ""
}

type Pays struct {
	WithDate             string   `protobuf:"bytes,1,opt,name=with_date,json=withDate,proto3" json:"with_date"`
	Amount               float64  `protobuf:"fixed64,2,opt,name=amount,proto3" json:"amount"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pays) Reset()         { *m = Pays{} }
func (m *Pays) String() string { return proto.CompactTextString(m) }
func (*Pays) ProtoMessage()    {}
func (*Pays) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{35}
}
func (m *Pays) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pays) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pays.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pays) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pays.Merge(m, src)
}
func (m *Pays) XXX_Size() int {
	return m.Size()
}
func (m *Pays) XXX_DiscardUnknown() {
	xxx_messageInfo_Pays.DiscardUnknown(m)
}

var xxx_messageInfo_Pays proto.InternalMessageInfo

func (m *Pays) GetWithDate() string {
	if m != nil {
		return m.WithDate
	}
	return ""
}

func (m *Pays) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type PaymentStudentList struct {
	Duration             []*PayStd `protobuf:"bytes,1,rep,name=duration,proto3" json:"duration"`
	Paid                 *Pays     `protobuf:"bytes,2,opt,name=paid,proto3" json:"paid"`
	Debt                 *Pays     `protobuf:"bytes,3,opt,name=debt,proto3" json:"debt"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *PaymentStudentList) Reset()         { *m = PaymentStudentList{} }
func (m *PaymentStudentList) String() string { return proto.CompactTextString(m) }
func (*PaymentStudentList) ProtoMessage()    {}
func (*PaymentStudentList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c04e2e1c1ba79a81, []int{36}
}
func (m *PaymentStudentList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentStudentList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentStudentList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentStudentList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentStudentList.Merge(m, src)
}
func (m *PaymentStudentList) XXX_Size() int {
	return m.Size()
}
func (m *PaymentStudentList) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentStudentList.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentStudentList proto.InternalMessageInfo

func (m *PaymentStudentList) GetDuration() []*PayStd {
	if m != nil {
		return m.Duration
	}
	return nil
}

func (m *PaymentStudentList) GetPaid() *Pays {
	if m != nil {
		return m.Paid
	}
	return nil
}

func (m *PaymentStudentList) GetDebt() *Pays {
	if m != nil {
		return m.Debt
	}
	return nil
}

func init() {
	proto.RegisterType((*EmptyRes)(nil), "finance_service.EmptyRes")
	proto.RegisterType((*EmptyReq)(nil), "finance_service.EmptyReq")
	proto.RegisterType((*Status)(nil), "finance_service.Status")
	proto.RegisterType((*StatusReq)(nil), "finance_service.StatusReq")
	proto.RegisterType((*PySt)(nil), "finance_service.PySt")
	proto.RegisterType((*StatusSpending)(nil), "finance_service.StatusSpending")
	proto.RegisterType((*StatusSpendingReq)(nil), "finance_service.StatusSpendingReq")
	proto.RegisterType((*Empty)(nil), "finance_service.Empty")
	proto.RegisterType((*Request)(nil), "finance_service.Request")
	proto.RegisterType((*Response)(nil), "finance_service.Response")
	proto.RegisterType((*ResponseList)(nil), "finance_service.ResponseList")
	proto.RegisterType((*Spending)(nil), "finance_service.Spending")
	proto.RegisterType((*By)(nil), "finance_service.By")
	proto.RegisterType((*ByP)(nil), "finance_service.ByP")
	proto.RegisterType((*SpendingResp)(nil), "finance_service.SpendingResp")
	proto.RegisterType((*Payment)(nil), "finance_service.Payment")
	proto.RegisterType((*PaymentResp)(nil), "finance_service.PaymentResp")
	proto.RegisterType((*PaymentListResp)(nil), "finance_service.PaymentListResp")
	proto.RegisterType((*SpendingListResp)(nil), "finance_service.SpendingListResp")
	proto.RegisterType((*Searching)(nil), "finance_service.Searching")
	proto.RegisterType((*PaymentSearchResp)(nil), "finance_service.PaymentSearchResp")
	proto.RegisterType((*ProfitResp)(nil), "finance_service.ProfitResp")
	proto.RegisterType((*ProfitRespList)(nil), "finance_service.ProfitRespList")
	proto.RegisterType((*ByIdReq)(nil), "finance_service.ByIdReq")
	proto.RegisterType((*ListReq)(nil), "finance_service.ListReq")
	proto.RegisterType((*SpendingListReq)(nil), "finance_service.SpendingListReq")
	proto.RegisterType((*SpendingListRequest)(nil), "finance_service.SpendingListRequest")
	proto.RegisterType((*PaymentSearchReq)(nil), "finance_service.PaymentSearchReq")
	proto.RegisterType((*SearchReq)(nil), "finance_service.SearchReq")
	proto.RegisterType((*Search)(nil), "finance_service.Search")
	proto.RegisterType((*Pay)(nil), "finance_service.Pay")
	proto.RegisterType((*SearchListResp)(nil), "finance_service.SearchListResp")
	proto.RegisterType((*Tesh)(nil), "finance_service.Tesh")
	proto.RegisterType((*Count)(nil), "finance_service.Count")
	proto.RegisterType((*PayStd)(nil), "finance_service.PayStd")
	proto.RegisterType((*Pays)(nil), "finance_service.Pays")
	proto.RegisterType((*PaymentStudentList)(nil), "finance_service.PaymentStudentList")
}

func init() { proto.RegisterFile("finance.proto", fileDescriptor_c04e2e1c1ba79a81) }

var fileDescriptor_c04e2e1c1ba79a81 = []byte{
	// 1644 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4b, 0x73, 0x1b, 0x45,
	0x10, 0x66, 0x77, 0xf5, 0x6c, 0x39, 0x8a, 0x33, 0x76, 0x82, 0xa2, 0xc4, 0x8f, 0x6c, 0x28, 0xca,
	0xae, 0x54, 0x9c, 0xc2, 0xa9, 0x0a, 0xa6, 0xc2, 0x21, 0x7e, 0x24, 0x41, 0xc1, 0xa1, 0xc4, 0x2a,
	0x14, 0x47, 0xd5, 0x44, 0x3b, 0x91, 0xb6, 0xb0, 0x56, 0xeb, 0xdd, 0x55, 0x60, 0xef, 0x1c, 0xf8,
	0x01, 0x54, 0xc1, 0x8d, 0x9f, 0xc0, 0x95, 0x1b, 0x57, 0x0e, 0x1c, 0xb8, 0x71, 0xa5, 0xc2, 0x1f,
	0xe0, 0x27, 0x50, 0xf3, 0xdc, 0xb7, 0xe2, 0xc4, 0x70, 0x9b, 0x47, 0x4f, 0x4f, 0xf7, 0xd7, 0xdf,
	0x74, 0xcf, 0x0c, 0x5c, 0x78, 0xe1, 0xb8, 0xd8, 0x1d, 0x91, 0x1d, 0xcf, 0x9f, 0x85, 0x33, 0x74,
	0x51, 0x74, 0x87, 0x01, 0xf1, 0x5f, 0x3a, 0x23, 0x62, 0x02, 0x34, 0x1e, 0x4e, 0xbd, 0x30, 0xb2,
	0x48, 0x60, 0xfe, 0xac, 0xa9, 0xce, 0x29, 0x6a, 0x83, 0xee, 0xd8, 0x1d, 0x6d, 0x53, 0xdb, 0x6a,
	0x5a, 0xba, 0x63, 0xa3, 0x2e, 0x34, 0x46, 0x38, 0x24, 0xe3, 0x99, 0x1f, 0x75, 0x74, 0x36, 0xaa,
	0xfa, 0x68, 0x03, 0x5a, 0x1e, 0xf1, 0x83, 0x99, 0x8b, 0x4f, 0x86, 0x8e, 0xdd, 0x31, 0xd8, 0x34,
	0xc8, 0xa1, 0x9e, 0x8d, 0xde, 0x83, 0x76, 0x80, 0x4f, 0xb0, 0x1f, 0x0d, 0xc3, 0xc8, 0x23, 0x54,
	0xa6, 0xc2, 0x64, 0x96, 0xf8, 0xe8, 0xb3, 0xc8, 0x23, 0x3d, 0x1b, 0x5d, 0x81, 0x1a, 0x9e, 0xce,
	0xe6, 0x6e, 0xd8, 0xa9, 0xb2, 0x59, 0xd1, 0x43, 0x1d, 0xa8, 0x8f, 0x66, 0xd3, 0x29, 0x71, 0xc3,
	0x4e, 0x8d, 0x4d, 0xc8, 0xae, 0xf9, 0x39, 0xd4, 0x06, 0x21, 0x0e, 0xe7, 0x41, 0xce, 0xdc, 0x8c,
	0x49, 0x7a, 0xce, 0xa4, 0x2b, 0x50, 0x0b, 0xd8, 0x52, 0x61, 0xae, 0xe8, 0x99, 0x1f, 0x43, 0x93,
	0xab, 0xa4, 0x20, 0xdc, 0x51, 0x42, 0xda, 0xa6, 0xb1, 0xd5, 0xda, 0x7d, 0x77, 0x27, 0x83, 0xdf,
	0x8e, 0x90, 0x95, 0xab, 0x1f, 0x40, 0xa5, 0x1f, 0x0d, 0x42, 0xb4, 0x06, 0x10, 0x84, 0x73, 0x9b,
	0xb8, 0xe1, 0x50, 0x99, 0xd5, 0x14, 0x23, 0x3d, 0x1b, 0x5d, 0x85, 0xc6, 0xd8, 0x9f, 0xcd, 0xbd,
	0xd8, 0xb4, 0x3a, 0xeb, 0xf7, 0x6c, 0x73, 0x0f, 0xda, 0x5c, 0xe7, 0xc0, 0x23, 0xae, 0xed, 0xb8,
	0xe3, 0x9c, 0x6b, 0xb1, 0xe5, 0x7a, 0xca, 0xf2, 0x63, 0xb8, 0x94, 0x5e, 0x49, 0x3d, 0xf8, 0x30,
	0xe3, 0xc1, 0x46, 0x89, 0x07, 0x6a, 0x8d, 0xd4, 0xb6, 0x01, 0x55, 0xc6, 0x85, 0xc4, 0x76, 0xd4,
	0x84, 0x86, 0x12, 0x58, 0x83, 0xba, 0x45, 0x4e, 0xe7, 0x24, 0x08, 0x11, 0x82, 0x8a, 0x8d, 0x43,
	0x22, 0x6c, 0x64, 0x6d, 0xf3, 0x77, 0x0d, 0x1a, 0x16, 0x09, 0xbc, 0x99, 0x1b, 0x90, 0x9c, 0x0b,
	0x08, 0x2a, 0x2e, 0x9e, 0x12, 0xe1, 0x00, 0x6b, 0xa3, 0x75, 0xa0, 0xe1, 0x99, 0x3a, 0x41, 0xe0,
	0xcc, 0xdc, 0x04, 0x87, 0xc4, 0x08, 0xba, 0x01, 0x82, 0x2d, 0xc3, 0xe9, 0xcc, 0x0d, 0x27, 0x82,
	0x41, 0x2d, 0x3e, 0xf6, 0x94, 0x0e, 0xa1, 0x5b, 0x50, 0x1d, 0x3b, 0x2f, 0x89, 0xdb, 0xa9, 0x32,
	0x5f, 0x2f, 0xe7, 0x7c, 0x7d, 0x46, 0x82, 0x89, 0xc5, 0x65, 0x98, 0xd1, 0xe4, 0x39, 0xa7, 0x94,
	0x66, 0xb1, 0x76, 0x92, 0x69, 0xf5, 0x34, 0xd3, 0xbe, 0x84, 0x25, 0xe9, 0xcd, 0xb1, 0x13, 0x84,
	0xe8, 0x03, 0xa8, 0xf1, 0x9d, 0x05, 0xae, 0x57, 0x73, 0x7b, 0x49, 0x71, 0x4b, 0x08, 0xa2, 0x55,
	0xa8, 0x8e, 0x18, 0xbb, 0xa9, 0xd7, 0x86, 0xc5, 0x3b, 0xe6, 0xb7, 0x3a, 0x34, 0x16, 0x85, 0x5a,
	0x9c, 0x08, 0xbd, 0xec, 0x44, 0x18, 0x29, 0x3b, 0x13, 0xd1, 0xaa, 0x24, 0xc9, 0x41, 0x19, 0xe7,
	0x45, 0x41, 0x14, 0x50, 0xc6, 0xf1, 0xd3, 0x55, 0x67, 0xfd, 0x9e, 0x8d, 0xae, 0x41, 0xf3, 0xb9,
	0x8f, 0xdd, 0xd1, 0x84, 0xce, 0xf1, 0x03, 0xd6, 0xe0, 0x03, 0x3d, 0x1b, 0x6d, 0xc1, 0x72, 0x20,
	0xac, 0x53, 0x67, 0x97, 0x43, 0xd3, 0x96, 0xe3, 0xe2, 0xf4, 0xae, 0x01, 0x8c, 0x7c, 0x82, 0x43,
	0x62, 0x0f, 0x71, 0xd8, 0x69, 0x70, 0xca, 0x8b, 0x91, 0x7d, 0x76, 0x22, 0xe6, 0x9e, 0x2d, 0xa7,
	0x9b, 0x7c, 0x5a, 0x8c, 0xec, 0x87, 0xe6, 0x16, 0xe8, 0x07, 0xd1, 0x59, 0x78, 0x62, 0x7e, 0x05,
	0xc6, 0x41, 0xd4, 0x3f, 0x13, 0xa5, 0xd6, 0x00, 0x42, 0x82, 0x47, 0x13, 0xe2, 0xc7, 0x69, 0xa9,
	0x29, 0x46, 0x7a, 0x36, 0x65, 0x94, 0x9c, 0x66, 0x4b, 0x05, 0xa3, 0xc4, 0xd8, 0x67, 0x74, 0xb3,
	0x5f, 0x74, 0x58, 0x8a, 0x8f, 0x53, 0xe0, 0xfd, 0x8f, 0x11, 0xda, 0x86, 0x2a, 0x8b, 0x08, 0x0b,
	0x4f, 0x6b, 0x77, 0x25, 0x47, 0xa8, 0x83, 0xc8, 0xe2, 0x12, 0x68, 0x0f, 0x2e, 0xa4, 0x82, 0xc2,
	0xa2, 0x56, 0xb2, 0x64, 0x29, 0x19, 0x26, 0x74, 0x0b, 0x6a, 0x3c, 0xb4, 0x2c, 0x88, 0x25, 0x4b,
	0x84, 0xc8, 0x39, 0x23, 0xfa, 0x83, 0x0e, 0xf5, 0x3e, 0x8e, 0x98, 0xcf, 0x67, 0x45, 0x0d, 0x41,
	0x85, 0xf9, 0xc3, 0x21, 0x63, 0x6d, 0x5a, 0x78, 0xec, 0xb9, 0x8f, 0x43, 0x9a, 0x15, 0x38, 0x62,
	0xaa, 0xbf, 0x88, 0xd5, 0xe9, 0x0c, 0x5c, 0xcb, 0x66, 0xe0, 0x1b, 0xb0, 0x64, 0x3b, 0x3e, 0x19,
	0x51, 0x35, 0x31, 0xa7, 0x5b, 0x6a, 0x2c, 0x93, 0xa4, 0x1b, 0xa9, 0x24, 0x9d, 0x41, 0xa6, 0xb9,
	0x18, 0x19, 0xc8, 0x22, 0xf3, 0x8f, 0x0e, 0x2d, 0x81, 0xcc, 0x1b, 0x71, 0xea, 0x4d, 0xd1, 0xd9,
	0xc9, 0xa0, 0x53, 0x12, 0x6e, 0x05, 0xd9, 0x6e, 0x0e, 0xb2, 0x92, 0x15, 0x09, 0x1c, 0xef, 0x15,
	0xe0, 0x58, 0xb2, 0x2a, 0x05, 0xee, 0x9d, 0x0c, 0xb8, 0xad, 0xdd, 0xd5, 0x82, 0x35, 0xfd, 0xff,
	0x0a, 0x72, 0x0c, 0x17, 0x05, 0xe2, 0x34, 0x7b, 0x33, 0xd4, 0xf7, 0xa0, 0xe1, 0xf1, 0x21, 0x59,
	0x1b, 0xaf, 0xe7, 0x2c, 0x48, 0x44, 0xc9, 0x52, 0xd2, 0x25, 0x89, 0x9c, 0xc0, 0xb2, 0xcc, 0x14,
	0x6a, 0x8f, 0xfb, 0xd0, 0x94, 0xc7, 0x4f, 0x6e, 0xb2, 0x96, 0x2f, 0xc0, 0x89, 0xfc, 0x62, 0xc5,
	0xf2, 0xe9, 0x6d, 0x9a, 0x72, 0x9b, 0xef, 0x35, 0x68, 0x0e, 0x08, 0xf6, 0x47, 0x13, 0x5a, 0x30,
	0x6e, 0x43, 0x5d, 0xc4, 0x82, 0xf1, 0xa7, 0x2c, 0xc2, 0x42, 0x26, 0xc5, 0x16, 0x3d, 0xc3, 0x96,
	0x55, 0x99, 0x7f, 0x38, 0xbd, 0x44, 0xaa, 0x41, 0x50, 0xf1, 0xb0, 0xb8, 0xaf, 0x69, 0x16, 0x6b,
	0xab, 0xca, 0x59, 0x8d, 0x2b, 0xa7, 0xf9, 0x0d, 0x5c, 0x12, 0x60, 0x71, 0xe3, 0x98, 0xfb, 0xdb,
	0x50, 0x65, 0xe1, 0x5b, 0x64, 0x1b, 0x97, 0x40, 0x7b, 0xd0, 0x0c, 0xa4, 0x57, 0x1d, 0x9d, 0x21,
	0xd5, 0xcd, 0x23, 0x25, 0x25, 0xac, 0x58, 0xd8, 0xbc, 0x07, 0xd0, 0xf7, 0x67, 0x2f, 0x1c, 0x8e,
	0xb8, 0x2c, 0x03, 0x5a, 0xa2, 0x0c, 0xa4, 0x80, 0xd4, 0x25, 0x90, 0x18, 0xda, 0xf1, 0x3a, 0x56,
	0xd3, 0x95, 0x9c, 0x96, 0x90, 0x43, 0x1f, 0x41, 0x53, 0x11, 0x57, 0x58, 0x76, 0x2d, 0x4f, 0x14,
	0xa5, 0xc9, 0x8a, 0xa5, 0xcd, 0xab, 0x50, 0x3f, 0x88, 0x7a, 0x76, 0xc1, 0x75, 0xda, 0xbc, 0x0b,
	0x75, 0xce, 0x92, 0x53, 0x0e, 0xf1, 0x98, 0x9b, 0x6c, 0x58, 0xac, 0x4d, 0x4d, 0x39, 0x71, 0xa6,
	0x8e, 0xa2, 0x18, 0xeb, 0x98, 0xdf, 0x69, 0x70, 0x31, 0xcd, 0xb1, 0x53, 0x74, 0x33, 0x5b, 0x0b,
	0x34, 0x71, 0xb3, 0x4e, 0xa6, 0x7d, 0xb9, 0x85, 0x5e, 0xb4, 0x85, 0x91, 0xd8, 0x02, 0x2d, 0x83,
	0x61, 0x63, 0x99, 0x4a, 0x68, 0x93, 0xca, 0x8d, 0xf1, 0x68, 0x82, 0x45, 0x82, 0xe5, 0x1d, 0x73,
	0x0c, 0x2b, 0x19, 0x4b, 0xe4, 0x4d, 0xf0, 0x6c, 0xbe, 0xc8, 0x8d, 0x8c, 0x82, 0x8d, 0x2a, 0xc9,
	0x8d, 0x9e, 0xc0, 0x72, 0x86, 0x58, 0xa7, 0x72, 0xad, 0x56, 0xb0, 0x56, 0x4f, 0xac, 0x15, 0xa0,
	0x1b, 0x0a, 0xf4, 0x43, 0x79, 0x74, 0xa8, 0x92, 0x0e, 0xd4, 0x45, 0xa5, 0x17, 0x8a, 0x64, 0x17,
	0x5d, 0x4f, 0x47, 0x9c, 0xa5, 0x92, 0x38, 0xa8, 0xbf, 0x6a, 0x50, 0xe3, 0x5a, 0xce, 0x74, 0x07,
	0xb9, 0x1d, 0x6f, 0x63, 0x2c, 0x38, 0xa1, 0x72, 0x6f, 0x13, 0x96, 0x18, 0xed, 0x06, 0xe2, 0x54,
	0x57, 0x18, 0x66, 0xa9, 0xb1, 0xcc, 0x3b, 0x49, 0x53, 0xf5, 0xe1, 0x7d, 0x30, 0x3c, 0x1c, 0x89,
	0xc4, 0xbd, 0x5a, 0x94, 0xcc, 0x2c, 0x2a, 0x60, 0xf6, 0xc1, 0xe8, 0xe3, 0x48, 0x1d, 0x6d, 0xad,
	0xe0, 0x68, 0xeb, 0x89, 0x4b, 0x31, 0xbd, 0x26, 0xcd, 0x42, 0x7c, 0x32, 0x14, 0x9b, 0x1a, 0x6c,
	0xae, 0xc5, 0xc6, 0xf6, 0xd9, 0x90, 0x39, 0x80, 0x36, 0x87, 0x44, 0x65, 0x3e, 0xfa, 0x72, 0x62,
	0x23, 0xe5, 0x2f, 0x27, 0x1e, 0x09, 0x21, 0x46, 0x63, 0x1a, 0xcc, 0xa7, 0x62, 0x63, 0xda, 0x34,
	0x7d, 0xa8, 0xd0, 0xfb, 0x7a, 0x0e, 0xe5, 0x55, 0x79, 0xcb, 0x97, 0xb1, 0x56, 0xd7, 0x79, 0xfa,
	0x06, 0x31, 0xe2, 0x37, 0x48, 0xf2, 0x12, 0x56, 0x29, 0xbb, 0x84, 0x55, 0x53, 0x6f, 0xa8, 0x35,
	0xa8, 0x1e, 0x32, 0x2c, 0x53, 0xb9, 0x40, 0xe5, 0xf8, 0x29, 0xd4, 0xfa, 0x38, 0x1a, 0x84, 0x76,
	0x2a, 0x93, 0x6a, 0xf9, 0x5b, 0xc9, 0xd7, 0x4e, 0x38, 0x19, 0xda, 0x58, 0x3e, 0x95, 0xeb, 0xb4,
	0x7f, 0x84, 0xa3, 0x44, 0xe8, 0x8c, 0x54, 0x69, 0x57, 0xc9, 0xb7, 0x92, 0x48, 0xbe, 0xe6, 0x7d,
	0xa8, 0xf4, 0x71, 0x14, 0xd0, 0x1b, 0xba, 0x50, 0xa8, 0x1e, 0x59, 0x0d, 0xae, 0x31, 0x24, 0x99,
	0xdb, 0x82, 0x62, 0x83, 0xf9, 0x93, 0x06, 0x48, 0x9e, 0x1c, 0x4e, 0x1c, 0x96, 0xe4, 0xee, 0xa6,
	0x0c, 0x2f, 0x0e, 0x0d, 0xf7, 0x31, 0xe1, 0xd1, 0xb6, 0xa0, 0x8a, 0xce, 0xa8, 0x75, 0xb9, 0x68,
	0x41, 0x20, 0x18, 0xb4, 0x2d, 0x18, 0x64, 0x2c, 0x14, 0xa5, 0x22, 0xbb, 0x7f, 0xb6, 0xa0, 0xfd,
	0x88, 0x4f, 0x0f, 0xf8, 0x2c, 0x3a, 0x84, 0x0b, 0xc2, 0xe6, 0x43, 0x56, 0xda, 0x51, 0xa7, 0xac,
	0x26, 0x77, 0x4b, 0x67, 0xd0, 0x03, 0x00, 0xd1, 0x7c, 0x4c, 0xc2, 0x02, 0x0d, 0x22, 0x27, 0x2f,
	0xd0, 0xd0, 0x53, 0x17, 0x34, 0x86, 0x59, 0x5e, 0x50, 0xe4, 0xbc, 0xee, 0x66, 0x99, 0x0a, 0x75,
	0x10, 0xfa, 0x99, 0xc2, 0xc8, 0x14, 0x96, 0x95, 0x36, 0xaa, 0x72, 0xa3, 0x64, 0x4e, 0x69, 0x8c,
	0x31, 0xfa, 0xc2, 0xb3, 0xdf, 0x16, 0xa3, 0x23, 0xa5, 0xe4, 0x88, 0x9c, 0x90, 0x42, 0x25, 0x12,
	0xa6, 0xfc, 0xd3, 0x56, 0xfe, 0x18, 0xa1, 0x23, 0xa8, 0xf1, 0xca, 0x87, 0xca, 0x85, 0x0a, 0x1c,
	0xca, 0xd4, 0xdd, 0xa7, 0xca, 0x16, 0x91, 0x57, 0xcb, 0x6d, 0x31, 0xcb, 0x1c, 0x4a, 0xdc, 0x3a,
	0x8e, 0xa1, 0x9d, 0xe6, 0x3d, 0x2a, 0x60, 0x61, 0x34, 0x08, 0xbb, 0x37, 0x4b, 0x95, 0x25, 0xce,
	0xcb, 0x27, 0xb0, 0x32, 0x60, 0xef, 0x77, 0xc1, 0x54, 0xc1, 0xcb, 0x52, 0x7f, 0x4f, 0xbb, 0x57,
	0x8a, 0xa7, 0xd0, 0xa7, 0xb0, 0x9c, 0xd2, 0x54, 0x4c, 0x4e, 0x51, 0x49, 0xbb, 0x6b, 0xa5, 0x1f,
	0x0a, 0xcc, 0xac, 0x1e, 0xac, 0xf0, 0x8f, 0x9b, 0x67, 0xbc, 0x70, 0x70, 0xcd, 0x45, 0xc4, 0x92,
	0x9f, 0x59, 0xa5, 0x76, 0x3d, 0x96, 0xff, 0x46, 0xfb, 0xf6, 0xd4, 0x71, 0xcf, 0xa1, 0xe8, 0x09,
	0xac, 0x72, 0xa1, 0xbe, 0xf8, 0x66, 0x3b, 0x87, 0xae, 0x47, 0xd0, 0x96, 0xf7, 0x8b, 0x52, 0xc4,
	0xa5, 0x40, 0xb7, 0x7c, 0x0a, 0x1d, 0x40, 0x4b, 0xb6, 0x17, 0x27, 0x83, 0x05, 0x3a, 0x06, 0xf1,
	0x1f, 0x00, 0xc3, 0x7e, 0xb3, 0x54, 0x54, 0xa6, 0x85, 0x1b, 0xaf, 0x91, 0x08, 0xbc, 0xa4, 0x83,
	0xe2, 0x18, 0xbf, 0x9d, 0x83, 0x0f, 0x63, 0x3d, 0xe7, 0x39, 0xc9, 0xc7, 0xb9, 0x6f, 0x47, 0xf3,
	0x75, 0x3f, 0x85, 0xe5, 0xd1, 0x3b, 0x58, 0xfe, 0xed, 0xd5, 0xba, 0xf6, 0xc7, 0xab, 0x75, 0xed,
	0xaf, 0x57, 0xeb, 0xda, 0x8f, 0x7f, 0xaf, 0xbf, 0xf3, 0xbc, 0xc6, 0xfe, 0x9f, 0xef, 0xfe, 0x1b,
	0x00, 0x00, 0xff, 0xff, 0xc5, 0x88, 0x1c, 0xf0, 0x90, 0x16, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FinanceServiceClient is the client API for FinanceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FinanceServiceClient interface {
	PaymentCreate(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Payment, error)
	PaymentGet(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*Payment, error)
	PaymentList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*PaymentListResp, error)
	PaymentSearchList(ctx context.Context, in *SearchReq, opts ...grpc.CallOption) (*SearchListResp, error)
	PaymentUpdate(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Payment, error)
	PaymentDelete(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*EmptyRes, error)
	Profit(ctx context.Context, in *EmptyRes, opts ...grpc.CallOption) (*ProfitRespList, error)
	PaymentSearch(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*PaymentSearchResp, error)
	PaymentStudent(ctx context.Context, in *PySt, opts ...grpc.CallOption) (*PaymentStudentList, error)
	SalaryFinanceCreate(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (*Empty, error)
	SalaryFinanceGet(ctx context.Context, in *Request, opts ...grpc.CallOption) (*ResponseList, error)
	StatusTeacherSalary(ctx context.Context, in *StatusReq, opts ...grpc.CallOption) (*Empty, error)
	StatusAdminSalary(ctx context.Context, in *StatusReq, opts ...grpc.CallOption) (*Empty, error)
	StatusPersonalSalary(ctx context.Context, in *StatusReq, opts ...grpc.CallOption) (*Empty, error)
	SpendingCreate(ctx context.Context, in *Spending, opts ...grpc.CallOption) (*Spending, error)
	SpendingGet(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*Spending, error)
	SpendingList(ctx context.Context, in *SpendingListReq, opts ...grpc.CallOption) (*SpendingListResp, error)
	SpendingUpdate(ctx context.Context, in *Spending, opts ...grpc.CallOption) (*Spending, error)
	SpendingDelete(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*EmptyRes, error)
	StatusSpending(ctx context.Context, in *StatusSpendingReq, opts ...grpc.CallOption) (*Empty, error)
}

type financeServiceClient struct {
	cc *grpc.ClientConn
}

func NewFinanceServiceClient(cc *grpc.ClientConn) FinanceServiceClient {
	return &financeServiceClient{cc}
}

func (c *financeServiceClient) PaymentCreate(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Payment, error) {
	out := new(Payment)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) PaymentGet(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*Payment, error) {
	out := new(Payment)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) PaymentList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*PaymentListResp, error) {
	out := new(PaymentListResp)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) PaymentSearchList(ctx context.Context, in *SearchReq, opts ...grpc.CallOption) (*SearchListResp, error) {
	out := new(SearchListResp)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentSearchList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) PaymentUpdate(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Payment, error) {
	out := new(Payment)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) PaymentDelete(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*EmptyRes, error) {
	out := new(EmptyRes)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) Profit(ctx context.Context, in *EmptyRes, opts ...grpc.CallOption) (*ProfitRespList, error) {
	out := new(ProfitRespList)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/Profit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) PaymentSearch(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*PaymentSearchResp, error) {
	out := new(PaymentSearchResp)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentSearch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) PaymentStudent(ctx context.Context, in *PySt, opts ...grpc.CallOption) (*PaymentStudentList, error) {
	out := new(PaymentStudentList)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/PaymentStudent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SalaryFinanceCreate(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SalaryFinanceCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SalaryFinanceGet(ctx context.Context, in *Request, opts ...grpc.CallOption) (*ResponseList, error) {
	out := new(ResponseList)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SalaryFinanceGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) StatusTeacherSalary(ctx context.Context, in *StatusReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/StatusTeacherSalary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) StatusAdminSalary(ctx context.Context, in *StatusReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/StatusAdminSalary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) StatusPersonalSalary(ctx context.Context, in *StatusReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/StatusPersonalSalary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SpendingCreate(ctx context.Context, in *Spending, opts ...grpc.CallOption) (*Spending, error) {
	out := new(Spending)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SpendingCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SpendingGet(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*Spending, error) {
	out := new(Spending)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SpendingGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SpendingList(ctx context.Context, in *SpendingListReq, opts ...grpc.CallOption) (*SpendingListResp, error) {
	out := new(SpendingListResp)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SpendingList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SpendingUpdate(ctx context.Context, in *Spending, opts ...grpc.CallOption) (*Spending, error) {
	out := new(Spending)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SpendingUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) SpendingDelete(ctx context.Context, in *ByIdReq, opts ...grpc.CallOption) (*EmptyRes, error) {
	out := new(EmptyRes)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/SpendingDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeServiceClient) StatusSpending(ctx context.Context, in *StatusSpendingReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/finance_service.FinanceService/StatusSpending", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FinanceServiceServer is the server API for FinanceService service.
type FinanceServiceServer interface {
	PaymentCreate(context.Context, *Payment) (*Payment, error)
	PaymentGet(context.Context, *ByIdReq) (*Payment, error)
	PaymentList(context.Context, *ListReq) (*PaymentListResp, error)
	PaymentSearchList(context.Context, *SearchReq) (*SearchListResp, error)
	PaymentUpdate(context.Context, *Payment) (*Payment, error)
	PaymentDelete(context.Context, *ByIdReq) (*EmptyRes, error)
	Profit(context.Context, *EmptyRes) (*ProfitRespList, error)
	PaymentSearch(context.Context, *ByIdReq) (*PaymentSearchResp, error)
	PaymentStudent(context.Context, *PySt) (*PaymentStudentList, error)
	SalaryFinanceCreate(context.Context, *EmptyReq) (*Empty, error)
	SalaryFinanceGet(context.Context, *Request) (*ResponseList, error)
	StatusTeacherSalary(context.Context, *StatusReq) (*Empty, error)
	StatusAdminSalary(context.Context, *StatusReq) (*Empty, error)
	StatusPersonalSalary(context.Context, *StatusReq) (*Empty, error)
	SpendingCreate(context.Context, *Spending) (*Spending, error)
	SpendingGet(context.Context, *ByIdReq) (*Spending, error)
	SpendingList(context.Context, *SpendingListReq) (*SpendingListResp, error)
	SpendingUpdate(context.Context, *Spending) (*Spending, error)
	SpendingDelete(context.Context, *ByIdReq) (*EmptyRes, error)
	StatusSpending(context.Context, *StatusSpendingReq) (*Empty, error)
}

// UnimplementedFinanceServiceServer can be embedded to have forward compatible implementations.
type UnimplementedFinanceServiceServer struct {
}

func (*UnimplementedFinanceServiceServer) PaymentCreate(ctx context.Context, req *Payment) (*Payment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentCreate not implemented")
}
func (*UnimplementedFinanceServiceServer) PaymentGet(ctx context.Context, req *ByIdReq) (*Payment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentGet not implemented")
}
func (*UnimplementedFinanceServiceServer) PaymentList(ctx context.Context, req *ListReq) (*PaymentListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentList not implemented")
}
func (*UnimplementedFinanceServiceServer) PaymentSearchList(ctx context.Context, req *SearchReq) (*SearchListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentSearchList not implemented")
}
func (*UnimplementedFinanceServiceServer) PaymentUpdate(ctx context.Context, req *Payment) (*Payment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentUpdate not implemented")
}
func (*UnimplementedFinanceServiceServer) PaymentDelete(ctx context.Context, req *ByIdReq) (*EmptyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentDelete not implemented")
}
func (*UnimplementedFinanceServiceServer) Profit(ctx context.Context, req *EmptyRes) (*ProfitRespList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Profit not implemented")
}
func (*UnimplementedFinanceServiceServer) PaymentSearch(ctx context.Context, req *ByIdReq) (*PaymentSearchResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentSearch not implemented")
}
func (*UnimplementedFinanceServiceServer) PaymentStudent(ctx context.Context, req *PySt) (*PaymentStudentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentStudent not implemented")
}
func (*UnimplementedFinanceServiceServer) SalaryFinanceCreate(ctx context.Context, req *EmptyReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SalaryFinanceCreate not implemented")
}
func (*UnimplementedFinanceServiceServer) SalaryFinanceGet(ctx context.Context, req *Request) (*ResponseList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SalaryFinanceGet not implemented")
}
func (*UnimplementedFinanceServiceServer) StatusTeacherSalary(ctx context.Context, req *StatusReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusTeacherSalary not implemented")
}
func (*UnimplementedFinanceServiceServer) StatusAdminSalary(ctx context.Context, req *StatusReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusAdminSalary not implemented")
}
func (*UnimplementedFinanceServiceServer) StatusPersonalSalary(ctx context.Context, req *StatusReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusPersonalSalary not implemented")
}
func (*UnimplementedFinanceServiceServer) SpendingCreate(ctx context.Context, req *Spending) (*Spending, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpendingCreate not implemented")
}
func (*UnimplementedFinanceServiceServer) SpendingGet(ctx context.Context, req *ByIdReq) (*Spending, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpendingGet not implemented")
}
func (*UnimplementedFinanceServiceServer) SpendingList(ctx context.Context, req *SpendingListReq) (*SpendingListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpendingList not implemented")
}
func (*UnimplementedFinanceServiceServer) SpendingUpdate(ctx context.Context, req *Spending) (*Spending, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpendingUpdate not implemented")
}
func (*UnimplementedFinanceServiceServer) SpendingDelete(ctx context.Context, req *ByIdReq) (*EmptyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpendingDelete not implemented")
}
func (*UnimplementedFinanceServiceServer) StatusSpending(ctx context.Context, req *StatusSpendingReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusSpending not implemented")
}

func RegisterFinanceServiceServer(s *grpc.Server, srv FinanceServiceServer) {
	s.RegisterService(&_FinanceService_serviceDesc, srv)
}

func _FinanceService_PaymentCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Payment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentCreate(ctx, req.(*Payment))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_PaymentGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentGet(ctx, req.(*ByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_PaymentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentList(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_PaymentSearchList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentSearchList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentSearchList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentSearchList(ctx, req.(*SearchReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_PaymentUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Payment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentUpdate(ctx, req.(*Payment))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_PaymentDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentDelete(ctx, req.(*ByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_Profit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).Profit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/Profit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).Profit(ctx, req.(*EmptyRes))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_PaymentSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentSearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentSearch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentSearch(ctx, req.(*ByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_PaymentStudent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PySt)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).PaymentStudent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/PaymentStudent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).PaymentStudent(ctx, req.(*PySt))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SalaryFinanceCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SalaryFinanceCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SalaryFinanceCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SalaryFinanceCreate(ctx, req.(*EmptyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SalaryFinanceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SalaryFinanceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SalaryFinanceGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SalaryFinanceGet(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_StatusTeacherSalary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).StatusTeacherSalary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/StatusTeacherSalary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).StatusTeacherSalary(ctx, req.(*StatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_StatusAdminSalary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).StatusAdminSalary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/StatusAdminSalary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).StatusAdminSalary(ctx, req.(*StatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_StatusPersonalSalary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).StatusPersonalSalary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/StatusPersonalSalary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).StatusPersonalSalary(ctx, req.(*StatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SpendingCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Spending)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SpendingCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SpendingCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SpendingCreate(ctx, req.(*Spending))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SpendingGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SpendingGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SpendingGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SpendingGet(ctx, req.(*ByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SpendingList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpendingListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SpendingList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SpendingList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SpendingList(ctx, req.(*SpendingListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SpendingUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Spending)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SpendingUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SpendingUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SpendingUpdate(ctx, req.(*Spending))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_SpendingDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).SpendingDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/SpendingDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).SpendingDelete(ctx, req.(*ByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceService_StatusSpending_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusSpendingReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceServiceServer).StatusSpending(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/finance_service.FinanceService/StatusSpending",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceServiceServer).StatusSpending(ctx, req.(*StatusSpendingReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _FinanceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "finance_service.FinanceService",
	HandlerType: (*FinanceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PaymentCreate",
			Handler:    _FinanceService_PaymentCreate_Handler,
		},
		{
			MethodName: "PaymentGet",
			Handler:    _FinanceService_PaymentGet_Handler,
		},
		{
			MethodName: "PaymentList",
			Handler:    _FinanceService_PaymentList_Handler,
		},
		{
			MethodName: "PaymentSearchList",
			Handler:    _FinanceService_PaymentSearchList_Handler,
		},
		{
			MethodName: "PaymentUpdate",
			Handler:    _FinanceService_PaymentUpdate_Handler,
		},
		{
			MethodName: "PaymentDelete",
			Handler:    _FinanceService_PaymentDelete_Handler,
		},
		{
			MethodName: "Profit",
			Handler:    _FinanceService_Profit_Handler,
		},
		{
			MethodName: "PaymentSearch",
			Handler:    _FinanceService_PaymentSearch_Handler,
		},
		{
			MethodName: "PaymentStudent",
			Handler:    _FinanceService_PaymentStudent_Handler,
		},
		{
			MethodName: "SalaryFinanceCreate",
			Handler:    _FinanceService_SalaryFinanceCreate_Handler,
		},
		{
			MethodName: "SalaryFinanceGet",
			Handler:    _FinanceService_SalaryFinanceGet_Handler,
		},
		{
			MethodName: "StatusTeacherSalary",
			Handler:    _FinanceService_StatusTeacherSalary_Handler,
		},
		{
			MethodName: "StatusAdminSalary",
			Handler:    _FinanceService_StatusAdminSalary_Handler,
		},
		{
			MethodName: "StatusPersonalSalary",
			Handler:    _FinanceService_StatusPersonalSalary_Handler,
		},
		{
			MethodName: "SpendingCreate",
			Handler:    _FinanceService_SpendingCreate_Handler,
		},
		{
			MethodName: "SpendingGet",
			Handler:    _FinanceService_SpendingGet_Handler,
		},
		{
			MethodName: "SpendingList",
			Handler:    _FinanceService_SpendingList_Handler,
		},
		{
			MethodName: "SpendingUpdate",
			Handler:    _FinanceService_SpendingUpdate_Handler,
		},
		{
			MethodName: "SpendingDelete",
			Handler:    _FinanceService_SpendingDelete_Handler,
		},
		{
			MethodName: "StatusSpending",
			Handler:    _FinanceService_StatusSpending_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

func (m *EmptyRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmptyRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *EmptyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmptyReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SalaryTypeId) > 0 {
		i -= len(m.SalaryTypeId)
		copy(dAtA[i:], m.SalaryTypeId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.SalaryTypeId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PersonalId) > 0 {
		i -= len(m.PersonalId)
		copy(dAtA[i:], m.PersonalId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.PersonalId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Category) > 0 {
		i -= len(m.Category)
		copy(dAtA[i:], m.Category)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Category)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PersonalId) > 0 {
		i -= len(m.PersonalId)
		copy(dAtA[i:], m.PersonalId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.PersonalId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		for iNdEx := len(m.Status) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Status[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PySt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PySt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PySt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StudentId) > 0 {
		i -= len(m.StudentId)
		copy(dAtA[i:], m.StudentId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.StudentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatusSpending) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusSpending) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusSpending) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatusSpendingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusSpendingReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusSpendingReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		for iNdEx := len(m.Status) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Status[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Debt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Debt))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.Given) > 0 {
		for iNdEx := len(m.Given) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Given[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SalaryMonth) > 0 {
		i -= len(m.SalaryMonth)
		copy(dAtA[i:], m.SalaryMonth)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.SalaryMonth)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Salary) > 0 {
		for iNdEx := len(m.Salary) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Salary[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Spending) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Spending) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Spending) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SpendingTypeId) > 0 {
		i -= len(m.SpendingTypeId)
		copy(dAtA[i:], m.SpendingTypeId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.SpendingTypeId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BranchId) > 0 {
		i -= len(m.BranchId)
		copy(dAtA[i:], m.BranchId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.BranchId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PysysId) > 0 {
		i -= len(m.PysysId)
		copy(dAtA[i:], m.PysysId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.PysysId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *By) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *By) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *By) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ByP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ByP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ByP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TeacherName) > 0 {
		i -= len(m.TeacherName)
		copy(dAtA[i:], m.TeacherName)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.TeacherName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TeacherId) > 0 {
		i -= len(m.TeacherId)
		copy(dAtA[i:], m.TeacherId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.TeacherId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendingResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendingResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendingResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x42
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SpendingType != nil {
		{
			size, err := m.SpendingType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Pysys != nil {
		{
			size, err := m.Pysys.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Payment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DirectionId) > 0 {
		i -= len(m.DirectionId)
		copy(dAtA[i:], m.DirectionId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.DirectionId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.StudentId) > 0 {
		i -= len(m.StudentId)
		copy(dAtA[i:], m.StudentId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.StudentId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PysysId) > 0 {
		i -= len(m.PysysId)
		copy(dAtA[i:], m.PysysId)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.PysysId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Duration) > 0 {
		i -= len(m.Duration)
		copy(dAtA[i:], m.Duration)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Duration)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PaymentResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x4a
	}
	if m.GroupId != nil {
		{
			size, err := m.GroupId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.DirectionId != nil {
		{
			size, err := m.DirectionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.StudentId != nil {
		{
			size, err := m.StudentId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.PysysId != nil {
		{
			size, err := m.PysysId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Duration) > 0 {
		i -= len(m.Duration)
		copy(dAtA[i:], m.Duration)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Duration)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PaymentListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Payments) > 0 {
		for iNdEx := len(m.Payments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpendingListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendingListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendingListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Count) > 0 {
		i -= len(m.Count)
		copy(dAtA[i:], m.Count)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Count)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Spendings) > 0 {
		for iNdEx := len(m.Spendings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spendings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Searching) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Searching) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Searching) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Debt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Debt))))
		i--
		dAtA[i] = 0x29
	}
	if m.Paid != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Paid))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.Pysys) > 0 {
		i -= len(m.Pysys)
		copy(dAtA[i:], m.Pysys)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Pysys)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Duration) > 0 {
		i -= len(m.Duration)
		copy(dAtA[i:], m.Duration)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Duration)))
		i--
		dAtA[i] = 0x12
	}
	if m.Student != nil {
		{
			size, err := m.Student.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PaymentSearchResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentSearchResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentSearchResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Searching) > 0 {
		for iNdEx := len(m.Searching) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Searching[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Group != nil {
		{
			size, err := m.Group.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProfitResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfitResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProfitResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Count))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProfitRespList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfitRespList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProfitRespList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Direction) > 0 {
		for iNdEx := len(m.Direction) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Direction[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Count != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Count))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *ByIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ByIdReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ByIdReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.Page != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpendingListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendingListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendingListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Gacha) > 0 {
		i -= len(m.Gacha)
		copy(dAtA[i:], m.Gacha)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Gacha)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Dan) > 0 {
		i -= len(m.Dan)
		copy(dAtA[i:], m.Dan)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Dan)))
		i--
		dAtA[i] = 0x22
	}
	if m.Limit != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if m.Page != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SpendingType) > 0 {
		i -= len(m.SpendingType)
		copy(dAtA[i:], m.SpendingType)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.SpendingType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendingListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendingListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendingListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Gacha) > 0 {
		i -= len(m.Gacha)
		copy(dAtA[i:], m.Gacha)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Gacha)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Dan) > 0 {
		i -= len(m.Dan)
		copy(dAtA[i:], m.Dan)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Dan)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Limit != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.Page != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PaymentSearchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentSearchReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentSearchReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Gacha) > 0 {
		i -= len(m.Gacha)
		copy(dAtA[i:], m.Gacha)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Gacha)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Dan) > 0 {
		i -= len(m.Dan)
		copy(dAtA[i:], m.Dan)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Dan)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Direction) > 0 {
		i -= len(m.Direction)
		copy(dAtA[i:], m.Direction)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Direction)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Teacher) > 0 {
		i -= len(m.Teacher)
		copy(dAtA[i:], m.Teacher)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Teacher)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Search) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Search) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Search) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pay != nil {
		{
			size, err := m.Pay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Amount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i--
		dAtA[i] = 0x29
	}
	if m.CountStudent != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.CountStudent))
		i--
		dAtA[i] = 0x20
	}
	if m.Teacher != nil {
		{
			size, err := m.Teacher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalAmount))))
		i--
		dAtA[i] = 0x19
	}
	if m.Debt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Debt))))
		i--
		dAtA[i] = 0x11
	}
	if m.Paid != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Paid))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *SearchListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sum != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Sum))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Search) > 0 {
		for iNdEx := len(m.Search) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Search[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Tesh) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tesh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tesh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Given) > 0 {
		i -= len(m.Given)
		copy(dAtA[i:], m.Given)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Given)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Count) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Count) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Count) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintFinance(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PayStd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayStd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayStd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pysys) > 0 {
		i -= len(m.Pysys)
		copy(dAtA[i:], m.Pysys)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Pysys)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.WithDay) > 0 {
		i -= len(m.WithDay)
		copy(dAtA[i:], m.WithDay)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.WithDay)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Duration) > 0 {
		i -= len(m.Duration)
		copy(dAtA[i:], m.Duration)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.Duration)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pays) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pays) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pays) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Amount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.WithDate) > 0 {
		i -= len(m.WithDate)
		copy(dAtA[i:], m.WithDate)
		i = encodeVarintFinance(dAtA, i, uint64(len(m.WithDate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PaymentStudentList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentStudentList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentStudentList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Debt != nil {
		{
			size, err := m.Debt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Paid != nil {
		{
			size, err := m.Paid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFinance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Duration) > 0 {
		for iNdEx := len(m.Duration) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Duration[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFinance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintFinance(dAtA []byte, offset int, v uint64) int {
	offset -= sovFinance(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EmptyRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EmptyReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.PersonalId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.SalaryTypeId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.PersonalId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Status) > 0 {
		for _, e := range m.Status {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PySt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StudentId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusSpending) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusSpendingReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Status) > 0 {
		for _, e := range m.Status {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.SalaryMonth)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if len(m.Given) > 0 {
		for _, e := range m.Given {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.Debt != 0 {
		n += 9
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Salary) > 0 {
		for _, e := range m.Salary {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovFinance(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Spending) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.PysysId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.BranchId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.SpendingTypeId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *By) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ByP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.TeacherId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.TeacherName)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpendingResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Pysys != nil {
		l = m.Pysys.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.SpendingType != nil {
		l = m.SpendingType.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Payment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.PysysId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.StudentId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.DirectionId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.PysysId != nil {
		l = m.PysysId.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.StudentId != nil {
		l = m.StudentId.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.DirectionId != nil {
		l = m.DirectionId.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.GroupId != nil {
		l = m.GroupId.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Payments) > 0 {
		for _, e := range m.Payments {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovFinance(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpendingListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Spendings) > 0 {
		for _, e := range m.Spendings {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	l = len(m.Count)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Searching) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Student != nil {
		l = m.Student.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Pysys)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Paid != 0 {
		n += 9
	}
	if m.Debt != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentSearchResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if len(m.Searching) > 0 {
		for _, e := range m.Searching {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProfitResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Count != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProfitRespList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 5
	}
	if len(m.Direction) > 0 {
		for _, e := range m.Direction {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ByIdReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovFinance(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovFinance(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpendingListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpendingType)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovFinance(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovFinance(uint64(m.Limit))
	}
	l = len(m.Dan)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Gacha)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpendingListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovFinance(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovFinance(uint64(m.Limit))
	}
	l = len(m.Dan)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Gacha)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentSearchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Dan)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Gacha)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Teacher)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Search) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Teacher != nil {
		l = m.Teacher.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.CountStudent != 0 {
		n += 1 + sovFinance(uint64(m.CountStudent))
	}
	if m.Amount != 0 {
		n += 9
	}
	if m.Pay != nil {
		l = m.Pay.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Paid != 0 {
		n += 9
	}
	if m.Debt != 0 {
		n += 9
	}
	if m.TotalAmount != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Search) > 0 {
		for _, e := range m.Search {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.Sum != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tesh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Given)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Count) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovFinance(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PayStd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.WithDay)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	l = len(m.Pysys)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pays) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WithDate)
	if l > 0 {
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Amount != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentStudentList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Duration) > 0 {
		for _, e := range m.Duration {
			l = e.Size()
			n += 1 + l + sovFinance(uint64(l))
		}
	}
	if m.Paid != nil {
		l = m.Paid.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.Debt != nil {
		l = m.Debt.Size()
		n += 1 + l + sovFinance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFinance(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFinance(x uint64) (n int) {
	return sovFinance(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EmptyRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmptyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SalaryTypeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SalaryTypeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = append(m.Status, &Status{})
			if err := m.Status[len(m.Status)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PySt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PySt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PySt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusSpending) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusSpending: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusSpending: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusSpendingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusSpendingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusSpendingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = append(m.Status, &StatusSpending{})
			if err := m.Status[len(m.Status)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SalaryMonth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SalaryMonth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Given", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Given = append(m.Given, &Tesh{})
			if err := m.Given[len(m.Given)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Debt = float64(math.Float64frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salary = append(m.Salary, &Response{})
			if err := m.Salary[len(m.Salary)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Spending) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spending: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spending: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PysysId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PysysId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BranchId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendingTypeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpendingTypeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *By) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: By: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: By: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ByP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ByP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ByP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeacherId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeacherId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeacherName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeacherName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendingResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendingResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendingResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pysys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pysys == nil {
				m.Pysys = &By{}
			}
			if err := m.Pysys.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendingType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpendingType == nil {
				m.SpendingType = &By{}
			}
			if err := m.SpendingType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &By{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PysysId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PysysId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PysysId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PysysId == nil {
				m.PysysId = &By{}
			}
			if err := m.PysysId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StudentId == nil {
				m.StudentId = &By{}
			}
			if err := m.StudentId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DirectionId == nil {
				m.DirectionId = &By{}
			}
			if err := m.DirectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupId == nil {
				m.GroupId = &ByP{}
			}
			if err := m.GroupId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payments = append(m.Payments, &PaymentResp{})
			if err := m.Payments[len(m.Payments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendingListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendingListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendingListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spendings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spendings = append(m.Spendings, &SpendingResp{})
			if err := m.Spendings[len(m.Spendings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Count = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Searching) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Searching: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Searching: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Student", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Student == nil {
				m.Student = &By{}
			}
			if err := m.Student.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pysys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pysys = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paid", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Paid = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Debt = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentSearchResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentSearchResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentSearchResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &By{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Searching", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Searching = append(m.Searching, &Searching{})
			if err := m.Searching[len(m.Searching)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfitResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfitResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfitResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Count = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfitRespList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfitRespList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfitRespList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Count = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = append(m.Direction, &ProfitResp{})
			if err := m.Direction[len(m.Direction)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ByIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ByIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ByIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendingListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendingListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendingListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendingType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpendingType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gacha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gacha = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendingListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendingListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendingListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gacha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gacha = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentSearchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentSearchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentSearchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gacha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gacha = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Teacher", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Teacher = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Search) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Search: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Search: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Teacher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Teacher == nil {
				m.Teacher = &By{}
			}
			if err := m.Teacher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountStudent", wireType)
			}
			m.CountStudent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountStudent |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pay == nil {
				m.Pay = &Pay{}
			}
			if err := m.Pay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paid", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Paid = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Debt = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalAmount = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Search = append(m.Search, &Search{})
			if err := m.Search[len(m.Search)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Sum = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tesh) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tesh: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tesh: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Given", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Given = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Count) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Count: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Count: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayStd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayStd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayStd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pysys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pysys = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pays) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pays: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pays: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentStudentList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentStudentList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentStudentList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = append(m.Duration, &PayStd{})
			if err := m.Duration[len(m.Duration)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Paid == nil {
				m.Paid = &Pays{}
			}
			if err := m.Paid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFinance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFinance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debt == nil {
				m.Debt = &Pays{}
			}
			if err := m.Debt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFinance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFinance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFinance(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFinance
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFinance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFinance
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFinance
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFinance
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFinance        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFinance          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFinance = fmt.Errorf("proto: unexpected end of group")
)
